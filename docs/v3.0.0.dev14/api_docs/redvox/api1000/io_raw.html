<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>redvox.api1000.io_raw API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>redvox.api1000.io_raw</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from collections import defaultdict
from datetime import datetime, timezone
from dataclasses import dataclass
from glob import glob
import os.path
from pathlib import Path
from typing import Dict, Iterator, List, Optional, Set

from redvox.api1000.wrapped_redvox_packet.wrapped_packet import WrappedRedvoxPacketM
from redvox.common.date_time_utils import datetime_from_epoch_microseconds_utc as dt_us


@dataclass
class ReadFilter:
    start_dt: Optional[datetime] = None
    end_dt: Optional[datetime] = None
    station_ids: Optional[Set[str]] = None
    extension: str = &#34;.rdvxm&#34;

    def with_start_dt(self, start_dt: datetime) -&gt; &#39;ReadFilter&#39;:
        self.start_dt = start_dt
        return self

    def with_start_ts(self, start_ts: float) -&gt; &#39;ReadFilter&#39;:
        return self.with_start_dt(dt_us(start_ts))

    def with_end_dt(self, end_dt: datetime) -&gt; &#39;ReadFilter&#39;:
        self.end_dt = end_dt
        return self

    def with_end_ts(self, end_ts: float) -&gt; &#39;ReadFilter&#39;:
        return self.with_end_dt(dt_us(end_ts))

    def with_station_ids(self, station_ids: Set[str]) -&gt; &#39;ReadFilter&#39;:
        self.station_ids = station_ids
        return self

    def with_extension(self, extension: str) -&gt; &#39;ReadFilter&#39;:
        self.extension = extension
        return self

    def filter_dt(self, dt: datetime):
        if self.start_dt is not None and dt &lt; self.start_dt:
            return False

        if self.end_dt is not None and dt &gt; self.end_dt:
            return False

        return True

    def filter_path(self, path: str) -&gt; bool:
        _path: Path = Path(path)
        ext: str = &#34;&#34;.join(_path.suffixes)
        station_ts: str = _path.stem
        split: List[str] = station_ts.split(&#34;_&#34;)
        station_id: str = split[0]
        ts: float = float(split[1])
        dt: datetime = dt_us(ts)

        if not self.filter_dt(dt):
            return False

        if self.station_ids is not None and station_id not in self.station_ids:
            return False

        if self.extension is not None and self.extension != ext:
            return False

        return True


class ReadResult:
    def __init__(self,
                 station_id_uuid_to_packets: Dict[str, List[WrappedRedvoxPacketM]]):
        self.station_id_uuid_to_packets: Dict[str, List[WrappedRedvoxPacketM]] = station_id_uuid_to_packets
        self.__station_id_to_id_uuid: Dict[str, str] = {}

        for id_uuid, packets in self.station_id_uuid_to_packets.items():
            s: List[str] = id_uuid.split(&#34;:&#34;)
            self.__station_id_to_id_uuid[s[0]] = s[1]

    @staticmethod
    def from_packets(packets: List[WrappedRedvoxPacketM]) -&gt; &#39;ReadResult&#39;:
        station_id_uuid_to_packets: Dict[str, List[WrappedRedvoxPacketM]] = defaultdict(list)

        for packet in packets:
            station_info = packet.get_station_information()
            station_id: str = station_info.get_id()
            station_uuid: str = station_info.get_uuid()
            id_uuid: str = f&#34;{station_id}:{station_uuid}&#34;
            station_id_uuid_to_packets[id_uuid].append(packet)

        return ReadResult(station_id_uuid_to_packets)

    def __get_packets_for_station_id_uuid(self, station_id_uuid) -&gt; List[WrappedRedvoxPacketM]:
        if station_id_uuid in self.station_id_uuid_to_packets:
            return self.station_id_uuid_to_packets[station_id_uuid]

        return []

    def __get_packets_for_station_id(self, station_id: str) -&gt; List[WrappedRedvoxPacketM]:
        if station_id in self.__station_id_to_id_uuid:
            return self.__get_packets_for_station_id_uuid(self.__station_id_to_id_uuid[station_id])

        return []

    def get_station_id_uuids(self) -&gt; List[str]:
        return list(self.station_id_uuid_to_packets.keys())

    def get_packets_for_station_id(self, station_id: str) -&gt; List[WrappedRedvoxPacketM]:
        if &#34;:&#34; in station_id:
            return self.__get_packets_for_station_id_uuid(station_id)
        else:
            return self.__get_packets_for_station_id(station_id)


__VALID_YEARS: Set[str] = {f&#34;{i:04}&#34; for i in range(2018, 2031)}
__VALID_MONTHS: Set[str] = {f&#34;{i:02}&#34; for i in range(1, 13)}
__VALID_DATES: Set[str] = {f&#34;{i:02}&#34; for i in range(1, 32)}
__VALID_HOURS: Set[str] = {f&#34;{i:02}&#34; for i in range(0, 24)}


def __list_subdirs(base_dir: str, valid_choices: Set[str]) -&gt; List[str]:
    subdirs: Iterator[str] = map(lambda p: Path(p).name, glob(os.path.join(base_dir, &#34;*&#34;, &#34;&#34;)))
    return sorted(list(filter(valid_choices.__contains__, subdirs)))


def __parse_structured_layout(base_dir: str,
                              read_filter: ReadFilter = ReadFilter()) -&gt; List[str]:
    all_paths: List[str] = []
    for year in __list_subdirs(base_dir, __VALID_YEARS):
        for month in __list_subdirs(os.path.join(base_dir, year), __VALID_MONTHS):
            for day in __list_subdirs(os.path.join(base_dir, year, month), __VALID_DATES):
                for hour in __list_subdirs(os.path.join(base_dir, year, day), __VALID_HOURS):
                    if not read_filter.filter_dt(datetime(int(year),
                                                          int(month),
                                                          int(day),
                                                          int(hour),
                                                          tzinfo=timezone.utc)):
                        continue

                    paths: List[str] = glob(os.path.join(base_dir,
                                                         year,
                                                         month,
                                                         day,
                                                         hour,
                                                         f&#34;*.{read_filter.extension}&#34;))
                    valid_paths: List[str] = list(filter(lambda path: read_filter.filter_path(path), paths))
                    if len(valid_paths) &gt; 0:
                        all_paths.extend(valid_paths)

    return all_paths


def read_bufs(bufs: List[bytes]) -&gt; ReadResult:
    wrapped_packets: List[WrappedRedvoxPacketM] = list(sorted(map(WrappedRedvoxPacketM.from_compressed_bytes, bufs)))
    return ReadResult.from_packets(wrapped_packets)


def read_structured(base_dir: str, read_filter: ReadFilter = ReadFilter()) -&gt; ReadResult:
    paths: List[str] = __parse_structured_layout(base_dir, read_filter)
    wrapped_packets: List[WrappedRedvoxPacketM] = list(sorted(map(WrappedRedvoxPacketM.from_compressed_path, paths)))
    return ReadResult.from_packets(wrapped_packets)


def read_unstructured(base_dir: str, read_filter: ReadFilter = ReadFilter()) -&gt; ReadResult:
    paths: List[str] = glob(os.path.join(base_dir, f&#34;*.{read_filter.extension}&#34;))
    paths = list(filter(lambda path: read_filter.filter_path(path), paths))
    wrapped_packets: List[WrappedRedvoxPacketM] = list(sorted(map(WrappedRedvoxPacketM.from_compressed_path, paths)))
    return ReadResult.from_packets(wrapped_packets)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="redvox.api1000.io_raw.read_bufs"><code class="name flex">
<span>def <span class="ident">read_bufs</span></span>(<span>bufs: typing.List[bytes]) ‑> <a title="redvox.api1000.io_raw.ReadResult" href="#redvox.api1000.io_raw.ReadResult">ReadResult</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_bufs(bufs: List[bytes]) -&gt; ReadResult:
    wrapped_packets: List[WrappedRedvoxPacketM] = list(sorted(map(WrappedRedvoxPacketM.from_compressed_bytes, bufs)))
    return ReadResult.from_packets(wrapped_packets)</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.read_structured"><code class="name flex">
<span>def <span class="ident">read_structured</span></span>(<span>base_dir: str, read_filter: <a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a> = ReadFilter(start_dt=None, end_dt=None, station_ids=None, extension='.rdvxm')) ‑> <a title="redvox.api1000.io_raw.ReadResult" href="#redvox.api1000.io_raw.ReadResult">ReadResult</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_structured(base_dir: str, read_filter: ReadFilter = ReadFilter()) -&gt; ReadResult:
    paths: List[str] = __parse_structured_layout(base_dir, read_filter)
    wrapped_packets: List[WrappedRedvoxPacketM] = list(sorted(map(WrappedRedvoxPacketM.from_compressed_path, paths)))
    return ReadResult.from_packets(wrapped_packets)</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.read_unstructured"><code class="name flex">
<span>def <span class="ident">read_unstructured</span></span>(<span>base_dir: str, read_filter: <a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a> = ReadFilter(start_dt=None, end_dt=None, station_ids=None, extension='.rdvxm')) ‑> <a title="redvox.api1000.io_raw.ReadResult" href="#redvox.api1000.io_raw.ReadResult">ReadResult</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_unstructured(base_dir: str, read_filter: ReadFilter = ReadFilter()) -&gt; ReadResult:
    paths: List[str] = glob(os.path.join(base_dir, f&#34;*.{read_filter.extension}&#34;))
    paths = list(filter(lambda path: read_filter.filter_path(path), paths))
    wrapped_packets: List[WrappedRedvoxPacketM] = list(sorted(map(WrappedRedvoxPacketM.from_compressed_path, paths)))
    return ReadResult.from_packets(wrapped_packets)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="redvox.api1000.io_raw.ReadFilter"><code class="flex name class">
<span>class <span class="ident">ReadFilter</span></span>
<span>(</span><span>start_dt: typing.Union[datetime.datetime, NoneType] = None, end_dt: typing.Union[datetime.datetime, NoneType] = None, station_ids: typing.Union[typing.Set[str], NoneType] = None, extension: str = '.rdvxm')</span>
</code></dt>
<dd>
<div class="desc"><p>ReadFilter(start_dt: typing.Union[datetime.datetime, NoneType] = None, end_dt: typing.Union[datetime.datetime, NoneType] = None, station_ids: typing.Union[typing.Set[str], NoneType] = None, extension: str = '.rdvxm')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReadFilter:
    start_dt: Optional[datetime] = None
    end_dt: Optional[datetime] = None
    station_ids: Optional[Set[str]] = None
    extension: str = &#34;.rdvxm&#34;

    def with_start_dt(self, start_dt: datetime) -&gt; &#39;ReadFilter&#39;:
        self.start_dt = start_dt
        return self

    def with_start_ts(self, start_ts: float) -&gt; &#39;ReadFilter&#39;:
        return self.with_start_dt(dt_us(start_ts))

    def with_end_dt(self, end_dt: datetime) -&gt; &#39;ReadFilter&#39;:
        self.end_dt = end_dt
        return self

    def with_end_ts(self, end_ts: float) -&gt; &#39;ReadFilter&#39;:
        return self.with_end_dt(dt_us(end_ts))

    def with_station_ids(self, station_ids: Set[str]) -&gt; &#39;ReadFilter&#39;:
        self.station_ids = station_ids
        return self

    def with_extension(self, extension: str) -&gt; &#39;ReadFilter&#39;:
        self.extension = extension
        return self

    def filter_dt(self, dt: datetime):
        if self.start_dt is not None and dt &lt; self.start_dt:
            return False

        if self.end_dt is not None and dt &gt; self.end_dt:
            return False

        return True

    def filter_path(self, path: str) -&gt; bool:
        _path: Path = Path(path)
        ext: str = &#34;&#34;.join(_path.suffixes)
        station_ts: str = _path.stem
        split: List[str] = station_ts.split(&#34;_&#34;)
        station_id: str = split[0]
        ts: float = float(split[1])
        dt: datetime = dt_us(ts)

        if not self.filter_dt(dt):
            return False

        if self.station_ids is not None and station_id not in self.station_ids:
            return False

        if self.extension is not None and self.extension != ext:
            return False

        return True</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="redvox.api1000.io_raw.ReadFilter.end_dt"><code class="name">var <span class="ident">end_dt</span> : typing.Union[datetime.datetime, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.extension"><code class="name">var <span class="ident">extension</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.start_dt"><code class="name">var <span class="ident">start_dt</span> : typing.Union[datetime.datetime, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.station_ids"><code class="name">var <span class="ident">station_ids</span> : typing.Union[typing.Set[str], NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.api1000.io_raw.ReadFilter.filter_dt"><code class="name flex">
<span>def <span class="ident">filter_dt</span></span>(<span>self, dt: datetime.datetime)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_dt(self, dt: datetime):
    if self.start_dt is not None and dt &lt; self.start_dt:
        return False

    if self.end_dt is not None and dt &gt; self.end_dt:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.filter_path"><code class="name flex">
<span>def <span class="ident">filter_path</span></span>(<span>self, path: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_path(self, path: str) -&gt; bool:
    _path: Path = Path(path)
    ext: str = &#34;&#34;.join(_path.suffixes)
    station_ts: str = _path.stem
    split: List[str] = station_ts.split(&#34;_&#34;)
    station_id: str = split[0]
    ts: float = float(split[1])
    dt: datetime = dt_us(ts)

    if not self.filter_dt(dt):
        return False

    if self.station_ids is not None and station_id not in self.station_ids:
        return False

    if self.extension is not None and self.extension != ext:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.with_end_dt"><code class="name flex">
<span>def <span class="ident">with_end_dt</span></span>(<span>self, end_dt: datetime.datetime) ‑> <a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_end_dt(self, end_dt: datetime) -&gt; &#39;ReadFilter&#39;:
    self.end_dt = end_dt
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.with_end_ts"><code class="name flex">
<span>def <span class="ident">with_end_ts</span></span>(<span>self, end_ts: float) ‑> <a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_end_ts(self, end_ts: float) -&gt; &#39;ReadFilter&#39;:
    return self.with_end_dt(dt_us(end_ts))</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.with_extension"><code class="name flex">
<span>def <span class="ident">with_extension</span></span>(<span>self, extension: str) ‑> <a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_extension(self, extension: str) -&gt; &#39;ReadFilter&#39;:
    self.extension = extension
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.with_start_dt"><code class="name flex">
<span>def <span class="ident">with_start_dt</span></span>(<span>self, start_dt: datetime.datetime) ‑> <a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_start_dt(self, start_dt: datetime) -&gt; &#39;ReadFilter&#39;:
    self.start_dt = start_dt
    return self</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.with_start_ts"><code class="name flex">
<span>def <span class="ident">with_start_ts</span></span>(<span>self, start_ts: float) ‑> <a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_start_ts(self, start_ts: float) -&gt; &#39;ReadFilter&#39;:
    return self.with_start_dt(dt_us(start_ts))</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.ReadFilter.with_station_ids"><code class="name flex">
<span>def <span class="ident">with_station_ids</span></span>(<span>self, station_ids: typing.Set[str]) ‑> <a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_station_ids(self, station_ids: Set[str]) -&gt; &#39;ReadFilter&#39;:
    self.station_ids = station_ids
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="redvox.api1000.io_raw.ReadResult"><code class="flex name class">
<span>class <span class="ident">ReadResult</span></span>
<span>(</span><span>station_id_uuid_to_packets: typing.Dict[str, typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReadResult:
    def __init__(self,
                 station_id_uuid_to_packets: Dict[str, List[WrappedRedvoxPacketM]]):
        self.station_id_uuid_to_packets: Dict[str, List[WrappedRedvoxPacketM]] = station_id_uuid_to_packets
        self.__station_id_to_id_uuid: Dict[str, str] = {}

        for id_uuid, packets in self.station_id_uuid_to_packets.items():
            s: List[str] = id_uuid.split(&#34;:&#34;)
            self.__station_id_to_id_uuid[s[0]] = s[1]

    @staticmethod
    def from_packets(packets: List[WrappedRedvoxPacketM]) -&gt; &#39;ReadResult&#39;:
        station_id_uuid_to_packets: Dict[str, List[WrappedRedvoxPacketM]] = defaultdict(list)

        for packet in packets:
            station_info = packet.get_station_information()
            station_id: str = station_info.get_id()
            station_uuid: str = station_info.get_uuid()
            id_uuid: str = f&#34;{station_id}:{station_uuid}&#34;
            station_id_uuid_to_packets[id_uuid].append(packet)

        return ReadResult(station_id_uuid_to_packets)

    def __get_packets_for_station_id_uuid(self, station_id_uuid) -&gt; List[WrappedRedvoxPacketM]:
        if station_id_uuid in self.station_id_uuid_to_packets:
            return self.station_id_uuid_to_packets[station_id_uuid]

        return []

    def __get_packets_for_station_id(self, station_id: str) -&gt; List[WrappedRedvoxPacketM]:
        if station_id in self.__station_id_to_id_uuid:
            return self.__get_packets_for_station_id_uuid(self.__station_id_to_id_uuid[station_id])

        return []

    def get_station_id_uuids(self) -&gt; List[str]:
        return list(self.station_id_uuid_to_packets.keys())

    def get_packets_for_station_id(self, station_id: str) -&gt; List[WrappedRedvoxPacketM]:
        if &#34;:&#34; in station_id:
            return self.__get_packets_for_station_id_uuid(station_id)
        else:
            return self.__get_packets_for_station_id(station_id)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="redvox.api1000.io_raw.ReadResult.from_packets"><code class="name flex">
<span>def <span class="ident">from_packets</span></span>(<span>packets: typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]) ‑> <a title="redvox.api1000.io_raw.ReadResult" href="#redvox.api1000.io_raw.ReadResult">ReadResult</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_packets(packets: List[WrappedRedvoxPacketM]) -&gt; &#39;ReadResult&#39;:
    station_id_uuid_to_packets: Dict[str, List[WrappedRedvoxPacketM]] = defaultdict(list)

    for packet in packets:
        station_info = packet.get_station_information()
        station_id: str = station_info.get_id()
        station_uuid: str = station_info.get_uuid()
        id_uuid: str = f&#34;{station_id}:{station_uuid}&#34;
        station_id_uuid_to_packets[id_uuid].append(packet)

    return ReadResult(station_id_uuid_to_packets)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="redvox.api1000.io_raw.ReadResult.get_packets_for_station_id"><code class="name flex">
<span>def <span class="ident">get_packets_for_station_id</span></span>(<span>self, station_id: str) ‑> typing.List[<a title="redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM" href="wrapped_redvox_packet/wrapped_packet.html#redvox.api1000.wrapped_redvox_packet.wrapped_packet.WrappedRedvoxPacketM">WrappedRedvoxPacketM</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_packets_for_station_id(self, station_id: str) -&gt; List[WrappedRedvoxPacketM]:
    if &#34;:&#34; in station_id:
        return self.__get_packets_for_station_id_uuid(station_id)
    else:
        return self.__get_packets_for_station_id(station_id)</code></pre>
</details>
</dd>
<dt id="redvox.api1000.io_raw.ReadResult.get_station_id_uuids"><code class="name flex">
<span>def <span class="ident">get_station_id_uuids</span></span>(<span>self) ‑> typing.List[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_station_id_uuids(self) -&gt; List[str]:
    return list(self.station_id_uuid_to_packets.keys())</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="redvox.api1000" href="index.html">redvox.api1000</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="redvox.api1000.io_raw.read_bufs" href="#redvox.api1000.io_raw.read_bufs">read_bufs</a></code></li>
<li><code><a title="redvox.api1000.io_raw.read_structured" href="#redvox.api1000.io_raw.read_structured">read_structured</a></code></li>
<li><code><a title="redvox.api1000.io_raw.read_unstructured" href="#redvox.api1000.io_raw.read_unstructured">read_unstructured</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="redvox.api1000.io_raw.ReadFilter" href="#redvox.api1000.io_raw.ReadFilter">ReadFilter</a></code></h4>
<ul class="two-column">
<li><code><a title="redvox.api1000.io_raw.ReadFilter.end_dt" href="#redvox.api1000.io_raw.ReadFilter.end_dt">end_dt</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.extension" href="#redvox.api1000.io_raw.ReadFilter.extension">extension</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.filter_dt" href="#redvox.api1000.io_raw.ReadFilter.filter_dt">filter_dt</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.filter_path" href="#redvox.api1000.io_raw.ReadFilter.filter_path">filter_path</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.start_dt" href="#redvox.api1000.io_raw.ReadFilter.start_dt">start_dt</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.station_ids" href="#redvox.api1000.io_raw.ReadFilter.station_ids">station_ids</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.with_end_dt" href="#redvox.api1000.io_raw.ReadFilter.with_end_dt">with_end_dt</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.with_end_ts" href="#redvox.api1000.io_raw.ReadFilter.with_end_ts">with_end_ts</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.with_extension" href="#redvox.api1000.io_raw.ReadFilter.with_extension">with_extension</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.with_start_dt" href="#redvox.api1000.io_raw.ReadFilter.with_start_dt">with_start_dt</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.with_start_ts" href="#redvox.api1000.io_raw.ReadFilter.with_start_ts">with_start_ts</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadFilter.with_station_ids" href="#redvox.api1000.io_raw.ReadFilter.with_station_ids">with_station_ids</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="redvox.api1000.io_raw.ReadResult" href="#redvox.api1000.io_raw.ReadResult">ReadResult</a></code></h4>
<ul class="">
<li><code><a title="redvox.api1000.io_raw.ReadResult.from_packets" href="#redvox.api1000.io_raw.ReadResult.from_packets">from_packets</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadResult.get_packets_for_station_id" href="#redvox.api1000.io_raw.ReadResult.get_packets_for_station_id">get_packets_for_station_id</a></code></li>
<li><code><a title="redvox.api1000.io_raw.ReadResult.get_station_id_uuids" href="#redvox.api1000.io_raw.ReadResult.get_station_id_uuids">get_station_id_uuids</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>