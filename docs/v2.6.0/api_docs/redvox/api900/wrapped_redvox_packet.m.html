<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>redvox.api900.wrapped_redvox_packet API documentation</title>
    <meta name="description" content="This module contains classes and methods for working with WrappedRedvoxPackets" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></span>
        
          
  <ul>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.__init__">__init__</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.accelerometer_channel">accelerometer_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.accelerometer_sensor">accelerometer_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.acquisition_server">acquisition_server</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.add_metadata">add_metadata</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.api">api</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_file_start_timestamp_epoch_microseconds_utc">app_file_start_timestamp_epoch_microseconds_utc</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_file_start_timestamp_machine">app_file_start_timestamp_machine</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_version">app_version</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authenticated_email">authenticated_email</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authentication_server">authentication_server</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authentication_token">authentication_token</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.barometer_channel">barometer_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.barometer_sensor">barometer_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.battery_level_percent">battery_level_percent</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.best_latency">best_latency</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.best_offset">best_offset</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.clone">clone</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.compressed_buffer">compressed_buffer</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.concat">concat</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.default_filename">default_filename</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_make">device_make</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_model">device_model</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_os">device_os</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_os_version">device_os_version</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_temperature_c">device_temperature_c</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.diff">diff</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.duration_s">duration_s</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.end_timestamp_us_utc">end_timestamp_us_utc</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.firebase_token">firebase_token</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.gyroscope_channel">gyroscope_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.gyroscope_sensor">gyroscope_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_accelerometer_channel">has_accelerometer_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_accelerometer_sensor">has_accelerometer_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_barometer_channel">has_barometer_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_barometer_sensor">has_barometer_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_gyroscope_channel">has_gyroscope_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_gyroscope_sensor">has_gyroscope_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_image_channel">has_image_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_image_sensor">has_image_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_infrared_channel">has_infrared_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_infrared_sensor">has_infrared_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_light_channel">has_light_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_light_sensor">has_light_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_location_channel">has_location_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_location_sensor">has_location_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_magnetometer_channel">has_magnetometer_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_magnetometer_sensor">has_magnetometer_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_microphone_channel">has_microphone_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_microphone_sensor">has_microphone_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_time_synchronization_channel">has_time_synchronization_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_time_synchronization_sensor">has_time_synchronization_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.image_channel">image_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.image_sensor">image_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.infrared_channel">infrared_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.infrared_sensor">infrared_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_backfilled">is_backfilled</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_private">is_private</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_scrambled">is_scrambled</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_synch_corrected">is_synch_corrected</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.light_channel">light_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.light_sensor">light_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.location_channel">location_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.location_sensor">location_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.mach_time_zero">mach_time_zero</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.magnetometer_channel">magnetometer_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.magnetometer_sensor">magnetometer_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.metadata">metadata</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.metadata_as_dict">metadata_as_dict</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.microphone_channel">microphone_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.microphone_sensor">microphone_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.redvox_id">redvox_id</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.redvox_packet">redvox_packet</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.server_timestamp_epoch_microseconds_utc">server_timestamp_epoch_microseconds_utc</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_accelerometer_channel">set_accelerometer_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_accelerometer_sensor">set_accelerometer_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_acquisition_server">set_acquisition_server</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_api">set_api</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_file_start_timestamp_epoch_microseconds_utc">set_app_file_start_timestamp_epoch_microseconds_utc</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_file_start_timestamp_machine">set_app_file_start_timestamp_machine</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_version">set_app_version</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authenticated_email">set_authenticated_email</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authentication_server">set_authentication_server</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authentication_token">set_authentication_token</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_barometer_channel">set_barometer_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_barometer_sensor">set_barometer_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_battery_level_percent">set_battery_level_percent</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_best_latency">set_best_latency</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_best_offset">set_best_offset</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_make">set_device_make</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_model">set_device_model</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_os">set_device_os</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_os_version">set_device_os_version</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_temperature_c">set_device_temperature_c</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_firebase_token">set_firebase_token</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_gyroscope_channel">set_gyroscope_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_gyroscope_sensor">set_gyroscope_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_image_channel">set_image_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_image_sensor">set_image_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_infrared_channel">set_infrared_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_infrared_sensor">set_infrared_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_backfilled">set_is_backfilled</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_private">set_is_private</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_scrambled">set_is_scrambled</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_synch_corrected">set_is_synch_corrected</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_light_channel">set_light_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_light_sensor">set_light_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_location_channel">set_location_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_location_sensor">set_location_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_mach_time_zero">set_mach_time_zero</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_magnetometer_channel">set_magnetometer_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_magnetometer_sensor">set_magnetometer_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_metadata">set_metadata</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_metadata_as_dict">set_metadata_as_dict</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_microphone_channel">set_microphone_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_microphone_sensor">set_microphone_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_redvox_id">set_redvox_id</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_server_timestamp_epoch_microseconds_utc">set_server_timestamp_epoch_microseconds_utc</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_time_synchronization_channel">set_time_synchronization_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_time_synchronization_sensor">set_time_synchronization_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_time_synchronization_server">set_time_synchronization_server</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_uuid">set_uuid</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.start_timestamp_us_utc">start_timestamp_us_utc</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.time_synchronization_channel">time_synchronization_channel</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.time_synchronization_sensor">time_synchronization_sensor</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.time_synchronization_server">time_synchronization_server</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.to_json">to_json</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.update_uneven_sensor_timestamps">update_uneven_sensor_timestamps</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.uuid">uuid</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.write_json">write_json</a></li>
    <li class="mono"><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.write_rdvxz">write_rdvxz</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">redvox.api900.wrapped_redvox_packet</span> module</h1>
  <p>This module contains classes and methods for working with WrappedRedvoxPackets</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet" class="source">
    <pre><code># pylint: disable=C0302
"""
This module contains classes and methods for working with WrappedRedvoxPackets
"""

import os
import typing

import redvox.api900.concat
import redvox.api900.date_time_utils as date_time_utils
import redvox.api900.deprecation as deprecation
import redvox.api900.lib.api900_pb2 as api900_pb2
import redvox.api900.reader
import redvox.api900.reader_utils as reader_utils
import redvox.api900.sensors.accelerometer_sensor as _accelerometer_sensor
import redvox.api900.sensors.barometer_sensor as _barometer_sensor
import redvox.api900.sensors.gyroscope_sensor as _gyroscope_sensor
import redvox.api900.sensors.image_sensor as _image_sensor
import redvox.api900.sensors.infrared_sensor as _infrared_sensor
import redvox.api900.sensors.light_sensor as _light_sensor
import redvox.api900.sensors.location_sensor as _location_sensor
import redvox.api900.sensors.magnetometer_sensor as _magnetometer_sensor
import redvox.api900.sensors.microphone_sensor as _microphone_sensor
import redvox.api900.sensors.time_synchronization_sensor as _time_synchronization_sensor
from redvox.api900.sensors.evenly_sampled_channel import EvenlySampledChannel
from redvox.api900.sensors.unevenly_sampled_channel import UnevenlySampledChannel


# pylint: disable=R0904
class WrappedRedvoxPacket:
    """
    This class provides convenience methods for accessing API 900 protobuf redvox packets.

    This packet contains a reference to the original packet which should be used to access all "top-level" fields. For
    accessing channels, this class can search for and return our high-level channel wrappers or can extract the payload
    directly.
    """

    def __init__(self, redvox_packet: api900_pb2.RedvoxPacket = None):
        """
        Initializes this wrapped redvox packet.
        :param redvox_packet: A protobuf redvox packet.
        """
        if redvox_packet is None:
            self._redvox_packet = api900_pb2.RedvoxPacket()
            self._evenly_sampled_channels_field = list()
            self._unevenly_sampled_channels_field = list()
            self._metadata_list = list()
            self._channel_cache = {}

        else:
            self._redvox_packet: api900_pb2.RedvoxPacket = redvox_packet
            """Protobuf api 900 redvox packet"""

            self._evenly_sampled_channels_field: typing.List[EvenlySampledChannel] = list(
                map(EvenlySampledChannel, reader_utils.repeated_to_array(redvox_packet.evenly_sampled_channels)))
            """List of evenly sampled channels"""

            self._unevenly_sampled_channels_field: typing.List[UnevenlySampledChannel] = list(
                map(UnevenlySampledChannel,
                    reader_utils.repeated_to_array(redvox_packet.unevenly_sampled_channels)))
            """List of unevenly sampled channels"""

            self._metadata_list: typing.List[str] = reader_utils.repeated_to_list(redvox_packet.metadata)
            """List of metadata"""

            self._channel_cache: typing.Dict[int, typing.Union[EvenlySampledChannel, UnevenlySampledChannel]] = {}
            """Holds a mapping of channel type to channel for O(1) access."""

            # Initialize channel cache
            for evenly_sampled_channel in self._evenly_sampled_channels_field:
                for channel_type in evenly_sampled_channel.channel_types:
                    self._channel_cache[channel_type] = evenly_sampled_channel

            for unevenly_sampled_channel in self._unevenly_sampled_channels_field:
                for channel_type in unevenly_sampled_channel.channel_types:
                    self._channel_cache[channel_type] = unevenly_sampled_channel

    def redvox_packet(self) -> api900_pb2.RedvoxPacket:
        """
        returns the protobuf redvox packet
        :return: protobuf redvox packet
        """
        return self._redvox_packet

    def _evenly_sampled_channels(self) -> typing.List[EvenlySampledChannel]:
        """
        returns the evenly sampled channels as a copied list to avoid built in functions making untracked changes
        :return: list of evenly sampled channels
        """
        return self._evenly_sampled_channels_field.copy()

    def _unevenly_sampled_channels(self) -> typing.List[UnevenlySampledChannel]:
        """
        returns the unevenly sampled channels as a copied list to avoid built in functions making untracked changes
        :return: list of unevenly sampled channels
        """
        return self._unevenly_sampled_channels_field.copy()

    def _refresh_channels(self):
        """
        takes the redvox packet and rebuilds the channel cache from it
        """
        self._evenly_sampled_channels_field = list(map(EvenlySampledChannel,
                                                       reader_utils.repeated_to_array(
                                                           self._redvox_packet.evenly_sampled_channels)))
        self._unevenly_sampled_channels_field = list(map(UnevenlySampledChannel,
                                                         reader_utils.repeated_to_array(
                                                             self._redvox_packet.unevenly_sampled_channels)))
        self._channel_cache = {}
        for evenly_sampled_channel in self._evenly_sampled_channels_field:
            for channel_type in evenly_sampled_channel.channel_types:
                self._channel_cache[channel_type] = evenly_sampled_channel
        for unevenly_sampled_channel in self._unevenly_sampled_channels_field:
            for channel_type in unevenly_sampled_channel.channel_types:
                self._channel_cache[channel_type] = unevenly_sampled_channel

    def _add_channel(self, channel: typing.Union[EvenlySampledChannel, UnevenlySampledChannel]):
        """
        Add a channel
        :param channel: channel to add
        """
        index, sample = self._find_channel(channel.channel_types[0])
        if index is None and sample is None:
            # if type(channel) not in [EvenlySampledChannel, UnevenlySampledChannel]:
            if not isinstance(channel, (EvenlySampledChannel, UnevenlySampledChannel)):
                raise TypeError("Channel type to add must be even or uneven.")
            else:
                self._add_channel_redvox_packet(channel)
                self._refresh_channels()
        else:
            raise ValueError("Cannot add a channel with a type that already exists in this packet.")

    def _edit_channel(self, channel_type: int, channel: typing.Union[EvenlySampledChannel, UnevenlySampledChannel]):
        """
        removes the channel with the given type and adds the channel supplied
        :param channel_type: type of channel to remove
        :param channel: the channel to add
        """
        index, sampling = self._find_channel(channel_type)
        if index is not None and sampling is not None:
            if isinstance(channel, EvenlySampledChannel):
                del self._redvox_packet.evenly_sampled_channels[index]
                self._add_channel_redvox_packet(channel)
            elif isinstance(channel, UnevenlySampledChannel):
                del self._redvox_packet.unevenly_sampled_channels[index]
                self._add_channel_redvox_packet(channel)
            else:
                raise TypeError("Channel type to edit is unknown!")
            self._refresh_channels()
        else:
            raise TypeError("Unknown channel type specified for edit.")

    def _delete_channel(self, channel_type: int):
        """
        deletes the channel type specified
        :param channel_type: a channel to remove
        """
        index, sampling = self._find_channel(channel_type)
        if index is not None and sampling is not None:
            if sampling == EvenlySampledChannel:
                del self._redvox_packet.evenly_sampled_channels[index]
            else:
                del self._redvox_packet.unevenly_sampled_channels[index]
            self._refresh_channels()
        else:
            raise TypeError("Unknown channel type to remove from packet.")

    # pylint: disable=W0120
    def _find_channel(self, channel_type: int) -> (int, typing.Union[EvenlySampledChannel, UnevenlySampledChannel]):
        """
        returns the index of the channel and the kind of sampled array its in
        :return: the index in the even or uneven array and the name of the array
        """
        if self._has_channel(channel_type):
            for idx in range(len(self._evenly_sampled_channels_field)):
                if channel_type in self._evenly_sampled_channels_field[idx].channel_types:
                    return idx, EvenlySampledChannel
            for idx in range(len(self._unevenly_sampled_channels_field)):
                if channel_type in self._unevenly_sampled_channels_field[idx].channel_types:
                    return idx, UnevenlySampledChannel
            else:
                return None, None
        else:
            return None, None

    # pylint: disable=R0912
    def _add_channel_redvox_packet(self, channel: typing.Union[EvenlySampledChannel, UnevenlySampledChannel]):
        """
        adds the channel to the redvox_packet
        :param channel: channel to add
        """
        if isinstance(channel, EvenlySampledChannel):
            newchan = self._redvox_packet.evenly_sampled_channels.add()
            newchan.sample_rate_hz = channel.sample_rate_hz
            newchan.first_sample_timestamp_epoch_microseconds_utc = \
                channel.first_sample_timestamp_epoch_microseconds_utc
        elif isinstance(channel, UnevenlySampledChannel):
            newchan = self._redvox_packet.unevenly_sampled_channels.add()
            for time in channel.timestamps_microseconds_utc:
                newchan.timestamps_microseconds_utc.append(time)
            newchan.sample_interval_mean = channel.sample_interval_mean
            newchan.sample_interval_std = channel.sample_interval_std
            newchan.sample_interval_median = channel.sample_interval_median
        else:
            raise TypeError("Channel type to add to redvox packet is unknown!")

        pl_type = channel.get_payload_type()
        if pl_type == "byte_payload":
            newchan.byte_payload.payload.extend(channel.payload)
        elif pl_type == "uint32_payload":
            newchan.uint32_payload.payload.extend(channel.payload)
        elif pl_type == "uint64_payload":
            newchan.uint64_payload.payload.extend(channel.payload)
        elif pl_type == "int32_payload":
            newchan.int32_payload.payload.extend(channel.payload)
        elif pl_type == "int64_payload":
            newchan.int64_payload.payload.extend(channel.payload)
        elif pl_type == "float32_payload":
            newchan.float32_payload.payload.extend(channel.payload)
        elif pl_type == "float64_payload":
            newchan.float64_payload.payload.extend(channel.payload)
        elif pl_type is None:
            pass
        else:
            raise TypeError("Unknown payload type in channel to add.")

        for chan_type in channel.channel_types:
            newchan.channel_types.append(chan_type)
        newchan.sensor_name = channel.sensor_name
        for mean in channel.value_means:
            newchan.value_means.append(mean)
        for stds in channel.value_stds:
            newchan.value_stds.append(stds)
        for median in channel.value_medians:
            newchan.value_medians.append(median)
        for meta in channel.metadata:
            newchan.metadata.append(meta)

    def _get_channel_types(self) -> typing.List[typing.List[int]]:
        """
        Returns a list of channel type enumerations. This is a list of lists, and allows us to easily view
        interleaved channels.
        :return: A list of channel type enumerations.
        """
        channel_types = []
        for evenly_sampled_channel in self._evenly_sampled_channels_field:
            channel_types.append(evenly_sampled_channel.channel_types)

        for unevenly_sampled_channel in self._unevenly_sampled_channels_field:
            channel_types.append(unevenly_sampled_channel.channel_types)

        return channel_types

    def _get_channel_type_names(self) -> typing.List[typing.List[str]]:
        """
        Returns a list of channel type names. This is a list of lists, and allows us to easily view
        interleaved channels.
        :return: A list of channel type names. This is a list of lists, and allows us to easily view
        interleaved channels.
        """
        names = []
        for channel_types in self._get_channel_types():
            names.append(list(map(reader_utils.channel_type_name_from_enum, channel_types)))
        return names

    def _get_channel(self, channel_type: int) -> typing.Union[EvenlySampledChannel, UnevenlySampledChannel, None]:
        """
        Returns a channel from this packet according to the channel type.
        :param channel_type: The channel type to search for.
        :return: A high level channel wrapper or None.
        """
        if channel_type in self._channel_cache:
            return self._channel_cache[channel_type]

        return None

    def _has_channel(self, channel_type: int) -> bool:
        """
        Returns True if this packet contains a channel with this type otherwise False.
        :param channel_type: Channel type to search for.
        :return: True is this packet contains a channel with this type otherwise False.
        """
        return channel_type in self._channel_cache

    def _has_channels(self, channel_types: typing.List[int]) -> bool:
        """
        Checks that this packet contains all of the provided channels.
        :param channel_types: Channel types that this packet must contain.
        :return: True if this packet contains all provided channel types, False otherwise.
        """
        has_channel_results = map(self._has_channel, channel_types)
        for has_channel_result in has_channel_results:
            if not has_channel_result:
                return False
        return True

    def to_json(self) -> str:
        """
        Converts the protobuf packet stored in this wrapped packet to JSON.
        :return: The JSON representation of the protobuf encoded packet.
        """
        return reader_utils.to_json(self._redvox_packet)

    def compressed_buffer(self) -> bytes:
        """
        Returns the compressed buffer associated with this packet.
        :return: The compressed buffer associated with this packet.
        """
        return reader_utils.lz4_compress(self._redvox_packet.SerializeToString())

    def default_filename(self, extension: str = "rdvxz") -> str:
        """
        Constructs a default filename from the packet's metadata.
        :param extension: An optional extension to use.
        :return: A default filename from the packet's metadata.
        """
        return "%s_%d.%s" % (self.redvox_id(), int(round(self.app_file_start_timestamp_machine() / 1000.0)), extension)

    def write_rdvxz(self, directory: str, filename: typing.Optional[str] = None):
        """
        Writes a compressed .rdvxz file to the specified directory.
        :param directory: The directory to write the file to.
        :param filename: An optional filename (the default filename will be used if one is not provided).
        """
        filename = self.default_filename() if filename is None else filename
        path = os.path.join(directory, filename)
        with open(path, "wb") as rdvxz_out:
            rdvxz_out.write(self.compressed_buffer())

    def write_json(self, directory: str, filename: typing.Optional[str] = None):
        """
        Writes a RedVox compliant .json file to the specified directory.
        :param directory: The directory to write the file to.
        :param filename: An optional filename (the default filename will be used if one is not provided).
        """
        filename = self.default_filename(extension="json") if filename is None else filename
        path = os.path.join(directory, filename)
        with open(path, "w") as json_out:
            json_out.write(self.to_json())

    def clone(self) -> 'WrappedRedvoxPacket':
        """
        Returns a clone of this WrappedRedvoxPacket.
        :return: A clone of this WrappedRedvoxPacket.
        """
        return redvox.api900.reader.read_rdvxz_buffer(self.compressed_buffer())

    def concat(self, wrapped_redvox_packets: typing.List['WrappedRedvoxPacket']) -> typing.List['WrappedRedvoxPacket']:
        """
        Concatenates this packet with other packets.
        :param wrapped_redvox_packets: Other packets to concatenate with this packet.
        :return: A list of packets each containing a continuous set of data.
        """
        return redvox.api900.concat.concat_wrapped_redvox_packets([self] + wrapped_redvox_packets)

    # Start of packet level API getters and setters
    def api(self) -> int:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.api

    def set_api(self, version: int) -> 'WrappedRedvoxPacket':
        """
        sets the api version number
        :param version: version number
        """
        self._redvox_packet.api = version
        return self

    def uuid(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.uuid

    def set_uuid(self, uid: str) -> 'WrappedRedvoxPacket':
        """
        sets the uuid
        :param uid: uuid string
        """
        self._redvox_packet.uuid = uid
        return self

    def redvox_id(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.redvox_id

    def set_redvox_id(self, rid: str) -> 'WrappedRedvoxPacket':
        """
        sets the redvox id
        :param rid: redvox id string
        """
        self._redvox_packet.redvox_id = rid
        return self

    def authenticated_email(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.authenticated_email

    def set_authenticated_email(self, email: str) -> 'WrappedRedvoxPacket':
        """
        sets the authenticated email
        :param email: authenticated email string
        """
        self._redvox_packet.authenticated_email = email
        return self

    def authentication_token(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.authentication_token

    def set_authentication_token(self, token: str) -> 'WrappedRedvoxPacket':
        """
        sets the authentication token
        :param token: authentication token string
        """
        self._redvox_packet.authentication_token = token
        return self

    def firebase_token(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.firebase_token

    def set_firebase_token(self, token: str) -> 'WrappedRedvoxPacket':
        """
        sets the firebase token
        :param token: firebase token string
        """
        self._redvox_packet.firebase_token = token
        return self

    def is_backfilled(self) -> bool:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.is_backfilled

    def set_is_backfilled(self, tof: bool) -> 'WrappedRedvoxPacket':
        """
        sets the is_backfilled flag
        :param tof: true or false
        """
        self._redvox_packet.is_backfilled = tof
        return self

    def is_private(self) -> bool:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.is_private

    def set_is_private(self, tof: bool) -> 'WrappedRedvoxPacket':
        """
        sets the is_private flag
        :param tof: true or false
        """
        self._redvox_packet.is_private = tof
        return self

    def is_scrambled(self) -> bool:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.is_scrambled

    def set_is_scrambled(self, tof: bool) -> 'WrappedRedvoxPacket':
        """
        sets the is_scrambled flag
        :param tof: true or false
        """
        self._redvox_packet.is_scrambled = tof
        return self

    def device_make(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.device_make

    def set_device_make(self, make: str) -> 'WrappedRedvoxPacket':
        """
        sets the make of the device
        :param make: make of the device string
        """
        self._redvox_packet.device_make = make
        return self

    def device_model(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.device_model

    def set_device_model(self, model: str) -> 'WrappedRedvoxPacket':
        """
        sets the model of the device
        :param model: model of the device string
        """
        self._redvox_packet.device_model = model
        return self

    def device_os(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.device_os

    def set_device_os(self, device_os: str) -> 'WrappedRedvoxPacket':
        """
        sets the device operating system
        :param device_os: operating system string
        """
        self._redvox_packet.device_os = device_os
        return self

    def device_os_version(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.device_os_version

    def set_device_os_version(self, version: str) -> 'WrappedRedvoxPacket':
        """
        sets the device OS version
        :param version: device OS version string
        """
        self._redvox_packet.device_os_version = version
        return self

    def app_version(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.app_version

    def set_app_version(self, version: str) -> 'WrappedRedvoxPacket':
        """
        sets the app version number
        :param version: app version string
        """
        self._redvox_packet.app_version = version
        return self

    def battery_level_percent(self) -> float:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.battery_level_percent

    def set_battery_level_percent(self, percent: float) -> 'WrappedRedvoxPacket':
        """
        sets the percentage of battery left
        :param percent: percentage of battery left
        """
        self._redvox_packet.battery_level_percent = percent
        return self

    def device_temperature_c(self) -> float:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.device_temperature_c

    def set_device_temperature_c(self, temp: float) -> 'WrappedRedvoxPacket':
        """
        sets the device temperature in degrees Celsius
        :param temp: temperature in degrees Celsius
        """
        self._redvox_packet.device_temperature_c = temp
        return self

    def acquisition_server(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.acquisition_server

    def set_acquisition_server(self, server: str) -> 'WrappedRedvoxPacket':
        """
        sets the acquisition server url
        :param server: url to acquisition server
        """
        self._redvox_packet.acquisition_server = server
        return self

    # pylint: disable=invalid-name
    def time_synchronization_server(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.time_synchronization_server

    def set_time_synchronization_server(self, server: str) -> 'WrappedRedvoxPacket':
        """
        sets the time synchronization server url
        :param server: url to time synchronization server
        """
        self._redvox_packet.time_synchronization_server = server
        return self

    def authentication_server(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.authentication_server

    def set_authentication_server(self, server: str) -> 'WrappedRedvoxPacket':
        """
        sets the authentication server url
        :param server: url to authentication server
        """
        self._redvox_packet.authentication_server = server
        return self

    # pylint: disable=invalid-name
    def app_file_start_timestamp_epoch_microseconds_utc(self) -> int:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.app_file_start_timestamp_epoch_microseconds_utc

    def set_app_file_start_timestamp_epoch_microseconds_utc(self, time: int) -> 'WrappedRedvoxPacket':
        """
        sets the timestamp of packet creation
        :param time: time when packet was created in microseconds since utc epoch
        """
        self._redvox_packet.app_file_start_timestamp_epoch_microseconds_utc = time
        return self

    # pylint: disable=invalid-name
    def app_file_start_timestamp_machine(self) -> int:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.app_file_start_timestamp_machine

    def set_app_file_start_timestamp_machine(self, time: int) -> 'WrappedRedvoxPacket':
        """
        sets the internal machine timestamp of packet creation
        :param time: time when packet was created on local machine
        """
        self._redvox_packet.app_file_start_timestamp_machine = time
        return self

    # pylint: disable=invalid-name
    def server_timestamp_epoch_microseconds_utc(self) -> int:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.server_timestamp_epoch_microseconds_utc

    def set_server_timestamp_epoch_microseconds_utc(self, time: int) -> 'WrappedRedvoxPacket':
        """
        sets the server timestamp when the packet was received
        :param time: time when packet was received by server
        """
        self._redvox_packet.server_timestamp_epoch_microseconds_utc = time
        return self

    def metadata(self) -> typing.List[str]:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._metadata_list

    def set_metadata(self, data: typing.List[str]) -> 'WrappedRedvoxPacket':
        """
        sets the metadata
        :param data: metadata as list of strings
        """
        self._metadata_list = data
        self._redvox_packet.metadata[:] = data
        return self

    def _clear_metadata(self):
        """
        removes all of the packet level metadata from packet
        """
        del self._redvox_packet.metadata[:]
        self._metadata_list.clear()

    def metadata_as_dict(self) -> typing.Dict[str, str]:
        """
        Return this packet's metadata as a key-value Python dictionary.
        :return: This packet's metadata as a key-value Python dictionary.
        """
        return reader_utils.get_metadata_as_dict(self._metadata_list)

    def set_metadata_as_dict(self, metadata_dict: typing.Dict[str, str]) -> 'WrappedRedvoxPacket':
        """
        Sets the metadata using a dictionary.
        :param metadata_dict: Dictionary of metadata.
        :return: This WrappedRedvoxPacket.
        """
        self.set_metadata(reader_utils.metadata_dict_to_list(metadata_dict))
        return self

    def add_metadata(self, key: str, value: str) -> 'WrappedRedvoxPacket':
        """
        Adds a key pair value to the metadata.
        :param key: The key.
        :param value: The value.
        :return: This instance of a WrappedRedvoxPacket.
        """
        metadata = self.metadata_as_dict()
        metadata[key] = value if isinstance(value, str) else str(value)
        self.set_metadata_as_dict(metadata)
        return self

    def start_timestamp_us_utc(self) -> int:
        """
        Returns the start timestamp of a WrappedRedvoxPacket.
        :return: The start timestamp of a WrappedRedvoxPacket.
        """
        return self.microphone_sensor().first_sample_timestamp_epoch_microseconds_utc()

    def duration_s(self) -> float:
        """
        The duration of this WrappedRedvoxPacket in seconds.
        :return: The duration of this WrappedRedvoxPacket in seconds.
        """
        microphone_sensor = self.microphone_sensor()
        return len(microphone_sensor.payload_values()) / microphone_sensor.sample_rate_hz()

    def end_timestamp_us_utc(self):
        """
        Returns the end timestamp of a WrappedRedvoxPacket.
        :return: The end timestamp of a WrappedRedvoxPacket.
        """
        return self.start_timestamp_us_utc() + date_time_utils.seconds_to_microseconds(self.duration_s())

    def update_uneven_sensor_timestamps(self, time_delta: int or float):
        """
        Given a time delta in microseconds, will adjust all unevenly sampled sensor timestamps by that amount.
        Use negative values to adjust backwards in time.
        :param time_delta: amount of time to adjust timestamps in microseconds
        """
        for channel in self._unevenly_sampled_channels_field:
            if not channel.has_channel(api900_pb2.TIME_SYNCHRONIZATION):
                channel.set_timestamps_microseconds_utc(channel.timestamps_microseconds_utc + time_delta)

    def mach_time_zero(self) -> typing.Optional[int]:
        """
        Returns the mach time zero from the metadata if it exists.
        :return: The mach time zero from the metadata if it exists.
        """
        try:
            return int(self.metadata_as_dict()["machTimeZero"])
        except (KeyError, ValueError):
            return None

    def set_mach_time_zero(self, mach_time_zero: int) -> 'WrappedRedvoxPacket':
        """
        Sets the mach time zero in the packet's metadata.
        :param mach_time_zero: The mach time zero to use.
        :return: An instance of this wrapped packet.
        """
        return self.add_metadata("machTimeZero", str(mach_time_zero))

    def best_latency(self) -> typing.Optional[float]:
        """
        Returns the best latency from the metadata if it exists.
        :return: The best latency from the metadata if it exists.
        """
        try:
            return float(self.metadata_as_dict()["bestLatency"])
        except (KeyError, ValueError):
            return None

    def set_best_latency(self, best_latency: float) -> 'WrappedRedvoxPacket':
        """
        Sets the best latency in the packet's metadata.
        :param best_latency: The best latency to use.
        :return: An instance of this wrapped packet.
        """
        return self.add_metadata("bestLatency", str(best_latency))

    def best_offset(self) -> typing.Optional[float]:
        """
        Returns the best offset from the metadata if it exists.
        :return: The best offset from the metadata if it exists.
        """
        try:
            return float(self.metadata_as_dict()["bestOffset"])
        except (KeyError, ValueError):
            return None

    def set_best_offset(self, best_offset: float) -> 'WrappedRedvoxPacket':
        """
        Sets the best offset in the packet's metadata.
        :param best_offset: The best offset to use.
        :return: An instance of this wrapped packet.
        """
        return self.add_metadata("bestOffset", str(best_offset))

    def is_synch_corrected(self) -> bool:
        """
        Returns the isSynchCorrected value from the metadata if it exists.
        :return: The isSynchCorrected value from the metadata if it exists.
        """

        def _parse_bool(s: str) -> bool:
            return s == "true" or s == "True"

        try:
            return _parse_bool(self.metadata_as_dict()["isSynchCorrected"])
        except (KeyError, ValueError):
            return False

    def set_is_synch_corrected(self, is_synch_corrected: bool) -> 'WrappedRedvoxPacket':
        """
        Sets the is_synch_corrected field in the packet's metadata.
        :param is_synch_corrected: The is_synch_corrected field to use.
        :return: An instance of this wrapped packet.
        """
        return self.add_metadata("isSynchCorrected", "true" if is_synch_corrected else "false")

    # Sensor channels
    def has_microphone_sensor(self) -> bool:
        """
        Returns if this packet has a microphone channel.
        :return: If this packet has a microphone channel.
        """
        return self._has_channel(api900_pb2.MICROPHONE)

    def microphone_sensor(self) -> typing.Optional[_microphone_sensor.MicrophoneSensor]:
        """
        Returns the high-level microphone channel API or None if this packet doesn't contain a channel of this type.
        :return: the high-level microphone channel API or None if this packet doesn't contain a channel of this type.
        """
        if self.has_microphone_sensor():
            return _microphone_sensor.MicrophoneSensor(self._get_channel(api900_pb2.MICROPHONE))

        return None

    def set_microphone_sensor(self, microphone_sensor: typing.Optional[
            _microphone_sensor.MicrophoneSensor]) -> 'WrappedRedvoxPacket':
        """
        Sets this packets microphone sensor. A channel can be removed by passing in None.
        :param microphone_sensor: An optional instance of a microphone sensor.
        :return: This instance of a wrapped redvox packet.
        """
        if self.has_microphone_sensor():
            self._delete_channel(api900_pb2.MICROPHONE)

        if microphone_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(microphone_sensor._evenly_sampled_channel)

        return self

    @deprecation.deprecated("2.0.0", has_microphone_sensor)
    def has_microphone_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", microphone_sensor)
    def microphone_channel(self) -> typing.Optional[_microphone_sensor.MicrophoneSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_microphone_sensor)
    def set_microphone_channel(self, microphone_sensor: typing.Optional[
            _microphone_sensor.MicrophoneSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    def has_barometer_sensor(self) -> bool:
        """
        Returns if this packet has a barometer channel.
        :return: If this packet has a barometer channel.
        """
        return self._has_channel(api900_pb2.BAROMETER)

    def barometer_sensor(self) -> typing.Optional[_barometer_sensor.BarometerSensor]:
        """
        Returns the high-level barometer channel API or None if this packet doesn't contain a channel of this type.
        :return: the high-level barometer channel API or None if this packet doesn't contain a channel of this type.
        """
        if self.has_barometer_sensor():
            return _barometer_sensor.BarometerSensor(self._get_channel(api900_pb2.BAROMETER))

        return None

    def set_barometer_sensor(self, barometer_sensor: typing.Optional[
            _barometer_sensor.BarometerSensor]) -> 'WrappedRedvoxPacket':
        """
        Sets this packets barometer sensor. A channel can be removed by passing in None.
        :param barometer_sensor: An optional instance of a barometer sensor.
        :return: This instance of a wrapped redvox packet.
        """
        if self.has_barometer_sensor():
            self._delete_channel(api900_pb2.BAROMETER)

        if barometer_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(barometer_sensor._unevenly_sampled_channel)

        return self

    @deprecation.deprecated("2.0.0", barometer_sensor)
    def barometer_channel(self) -> typing.Optional[_barometer_sensor.BarometerSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", has_barometer_sensor)
    def has_barometer_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_barometer_sensor)
    def set_barometer_channel(self, barometer_sensor: typing.Optional[
            _barometer_sensor.BarometerSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    def has_location_sensor(self) -> bool:
        """
        Returns if this packet has a location channel.
        :return: If this packet has a location channel.
        """
        return (self._has_channels(
            [api900_pb2.LATITUDE, api900_pb2.LONGITUDE, api900_pb2.ALTITUDE, api900_pb2.SPEED,
             api900_pb2.ACCURACY]) or self._has_channels([api900_pb2.LATITUDE, api900_pb2.LONGITUDE]))

    def location_sensor(self) -> typing.Optional[_location_sensor.LocationSensor]:
        """
        Returns the high-level location channel API or None if this packet doesn't contain a channel of this type.
        :return: the high-level location channel API or None if this packet doesn't contain a channel of this type.
        """
        if self.has_location_sensor():
            return _location_sensor.LocationSensor(self._get_channel(api900_pb2.LATITUDE))

        return None

    def set_location_sensor(self,
                            location_sensor: typing.Optional[_location_sensor.LocationSensor]) -> 'WrappedRedvoxPacket':
        """
        Sets this packet's location sensor. A channel can be removed by passing in None.
        :param location_sensor: An optional instance of a location sensor.
        :return: This instance of a wrapped redvox packet.
        """
        if self.has_location_sensor():
            self._delete_channel(api900_pb2.LATITUDE)

        if location_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(location_sensor._unevenly_sampled_channel)

        return self

    @deprecation.deprecated("2.0.0", has_location_sensor)
    def has_location_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", location_sensor)
    def location_channel(self) -> typing.Optional[_location_sensor.LocationSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_location_sensor)
    def set_location_channel(self,
                             location_sensor: typing.Optional[
                                 _location_sensor.LocationSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    # pylint: disable=invalid-name,C1801
    def has_time_synchronization_sensor(self) -> bool:
        """
        Returns if this packet has a time synchronization channel.
        :return: If this packet has a time synchronization channel.
        """
        if self._has_channel(api900_pb2.TIME_SYNCHRONIZATION):
            ch = _time_synchronization_sensor.TimeSynchronizationSensor(
                self._get_channel(api900_pb2.TIME_SYNCHRONIZATION))
            return len(ch.payload_values()) > 0

        return False

    def time_synchronization_sensor(self) -> typing.Optional[_time_synchronization_sensor.TimeSynchronizationSensor]:
        """
        Returns the high-level time synchronization channel API or None if this packet doesn't contain a channel of
        this type.
        :return: the high-level time synchronization channel API or None if this packet doesn't contain a channel of
        this type.
        """
        if self.has_time_synchronization_sensor():
            return _time_synchronization_sensor.TimeSynchronizationSensor(
                self._get_channel(api900_pb2.TIME_SYNCHRONIZATION))

        return None

    def set_time_synchronization_sensor(self, time_synchronization_sensor: typing.Optional[
            _time_synchronization_sensor.TimeSynchronizationSensor]) -> 'WrappedRedvoxPacket':
        """
        Sets this packet's time sync sensor. A channel can be removed by passing in None.
        :param time_synchronization_sensor: An optional instance of a time sync sensor.
        :return: This instance of a wrapped redvox packet.
        """
        if self.has_time_synchronization_sensor():
            self._delete_channel(api900_pb2.TIME_SYNCHRONIZATION)

        if time_synchronization_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(time_synchronization_sensor._unevenly_sampled_channel)

        return self

    # pylint: disable=invalid-name,C1801
    @deprecation.deprecated("2.0.0", has_time_synchronization_sensor)
    def has_time_synchronization_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", time_synchronization_sensor)
    def time_synchronization_channel(self) -> typing.Optional[_time_synchronization_sensor.TimeSynchronizationSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_time_synchronization_sensor)
    def set_time_synchronization_channel(self, time_synchronization_sensor: typing.Optional[
            _time_synchronization_sensor.TimeSynchronizationSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    def has_accelerometer_sensor(self) -> bool:
        """
        Returns if this packet has an accelerometer channel.
        :return: If this packet has an accelerometer channel.
        """
        return self._has_channels([api900_pb2.ACCELEROMETER_X, api900_pb2.ACCELEROMETER_Y, api900_pb2.ACCELEROMETER_Z])

    def accelerometer_sensor(self) -> typing.Optional[_accelerometer_sensor.AccelerometerSensor]:
        """
        Returns the high-level accelerometer channel API or None if this packet doesn't contain a channel of this type.
        :return: the high-level accelerometer channel API or None if this packet doesn't contain a channel of this type.
        """
        if self.has_accelerometer_sensor():
            return _accelerometer_sensor.AccelerometerSensor(self._get_channel(api900_pb2.ACCELEROMETER_X))

        return None

    def set_accelerometer_sensor(self,
                                 accelerometer_sensor: typing.Optional[
                                     _accelerometer_sensor.AccelerometerSensor]) -> 'WrappedRedvoxPacket':
        """
        Sets this packet's accelerometer sensor. A channel can be removed by passing in None.
        :param accelerometer_sensor: An optional instance of a accelerometer sensor.
        """
        if self.has_accelerometer_sensor():
            self._delete_channel(api900_pb2.ACCELEROMETER_X)

        if accelerometer_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(accelerometer_sensor._unevenly_sampled_channel)

        return self

    @deprecation.deprecated("2.0.0", has_accelerometer_sensor)
    def has_accelerometer_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", accelerometer_sensor)
    def accelerometer_channel(self) -> typing.Optional[_accelerometer_sensor.AccelerometerSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_accelerometer_sensor)
    def set_accelerometer_channel(self,
                                  accelerometer_sensor: typing.Optional[
                                      _accelerometer_sensor.AccelerometerSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    def has_magnetometer_sensor(self) -> bool:
        """
        Returns if this packet has a magnetometer channel.
        :return: If this packet has a magnetometer channel.
        """
        return self._has_channels([api900_pb2.MAGNETOMETER_X, api900_pb2.MAGNETOMETER_Y, api900_pb2.MAGNETOMETER_Z])

    def magnetometer_sensor(self) -> typing.Optional[_magnetometer_sensor.MagnetometerSensor]:
        """
        Returns the high-level magnetometer channel API or None if this packet doesn't contain a channel of this type.
        :return: the high-level magnetometer channel API or None if this packet doesn't contain a channel of this type.
        """
        if self.has_magnetometer_sensor():
            return _magnetometer_sensor.MagnetometerSensor(self._get_channel(api900_pb2.MAGNETOMETER_X))

        return None

    def set_magnetometer_sensor(self,
                                magnetometer_sensor: typing.Optional[
                                    _magnetometer_sensor.MagnetometerSensor]) -> 'WrappedRedvoxPacket':
        """
        Sets this packet's magnetomer sensor. A channel can be removed by passing in None.
        :param magnetometer_sensor: An optional instance of a magnetometer sensor.
        :return: This instance of a wrapped redvox packet.
        """
        if self.has_magnetometer_sensor():
            self._delete_channel(api900_pb2.MAGNETOMETER_X)

        if magnetometer_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(magnetometer_sensor._unevenly_sampled_channel)

        return self

    @deprecation.deprecated("2.0.0", has_magnetometer_sensor)
    def has_magnetometer_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", magnetometer_sensor)
    def magnetometer_channel(self) -> typing.Optional[_magnetometer_sensor.MagnetometerSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_magnetometer_sensor)
    def set_magnetometer_channel(self,
                                 magnetometer_sensor: typing.Optional[
                                     _magnetometer_sensor.MagnetometerSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    def has_gyroscope_sensor(self) -> bool:
        """
        Returns if this packet has a gyroscope channel.
        :return: If this packet has a gyroscope channel.
        """
        return self._has_channels([api900_pb2.GYROSCOPE_X, api900_pb2.GYROSCOPE_Y, api900_pb2.GYROSCOPE_Z])

    def gyroscope_sensor(self) -> typing.Optional[_gyroscope_sensor.GyroscopeSensor]:
        """
        Returns the high-level gyroscope channel API or None if this packet doesn't contain a channel of this type.
        :return: the high-level gyroscope channel API or None if this packet doesn't contain a channel of this type.
        """
        if self.has_gyroscope_sensor():
            return _gyroscope_sensor.GyroscopeSensor(self._get_channel(api900_pb2.GYROSCOPE_X))

        return None

    def set_gyroscope_sensor(self, gyroscope_sensor: typing.Optional[
            _gyroscope_sensor.GyroscopeSensor]) -> 'WrappedRedvoxPacket':
        """
        Sets this packet's gyroscope sensor. A channel can be removed by passing in None.
        :param gyroscope_sensor: An optional instance of a gyroscope sensor.
        :return: This instance of a wrapped redvox packet.
        """
        if self.has_gyroscope_sensor():
            self._delete_channel(api900_pb2.GYROSCOPE_X)

        if gyroscope_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(gyroscope_sensor._unevenly_sampled_channel)

        return self

    @deprecation.deprecated("2.0.0", has_gyroscope_sensor)
    def has_gyroscope_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", gyroscope_sensor)
    def gyroscope_channel(self) -> typing.Optional[_gyroscope_sensor.GyroscopeSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_gyroscope_sensor)
    def set_gyroscope_channel(self, gyroscope_sensor: typing.Optional[
            _gyroscope_sensor.GyroscopeSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    def has_light_sensor(self) -> bool:
        """
        Returns if this packet has a light channel.
        :return: If this packet has a light channel.
        """
        return self._has_channel(api900_pb2.LIGHT)

    def light_sensor(self) -> typing.Optional[_light_sensor.LightSensor]:
        """
        Returns the high-level light channel API or None if this packet doesn't contain a channel of this type.
        :return: the high-level light channel API or None if this packet doesn't contain a channel of this type.
        """
        if self.has_light_sensor():
            return _light_sensor.LightSensor(self._get_channel(api900_pb2.LIGHT))

        return None

    def set_light_sensor(self, light_sensor: typing.Optional[_light_sensor.LightSensor]) -> 'WrappedRedvoxPacket':
        """
        Sets this packet's light sensor. A channel can be removed by passing in None.
        :param light_sensor: An optional instance of a light sensor.
        :return: This instance of a wrapped redvox packet.
        """
        if self.has_light_sensor():
            self._delete_channel(api900_pb2.LIGHT)

        if light_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(light_sensor._unevenly_sampled_channel)

        return self

    @deprecation.deprecated("2.0.0", has_light_sensor)
    def has_light_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", light_sensor)
    def light_channel(self) -> typing.Optional[_light_sensor.LightSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_light_sensor)
    def set_light_channel(self, light_sensor: typing.Optional[_light_sensor.LightSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    def has_infrared_sensor(self) -> bool:
        """
        Returns if this packet has an infrared channel.
        :return: If this packlet has an infrared channel.
        """
        return self._has_channel(api900_pb2.INFRARED)

    def infrared_sensor(self) -> typing.Optional[_infrared_sensor.InfraredSensor]:
        """
        Returns the high-level infrared channel API or None if this packet doesn't contain a channel of this type.
        :return: the high-level infrared channel API or None if this packet doesn't contain a channel of this type.
        """
        if self.has_infrared_sensor():
            return _infrared_sensor.InfraredSensor(self._get_channel(api900_pb2.INFRARED))

        return None

    def set_infrared_sensor(self,
                            infrared_sensor: typing.Optional[
                                _infrared_sensor.InfraredSensor]) -> 'WrappedRedvoxPacket':
        """
        Sets this packet's infrared sensor. A channel can be removed by passing in None.
        :param infrared_sensor: An optional instance of a infrared sensor.
        """
        if self.has_infrared_sensor():
            self._delete_channel(api900_pb2.INFRARED)

        if infrared_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(infrared_sensor._unevenly_sampled_channel)

        return self

    @deprecation.deprecated("2.0.0", has_infrared_sensor)
    def has_infrared_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", infrared_sensor)
    def infrared_channel(self) -> typing.Optional[_infrared_sensor.InfraredSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_infrared_sensor)
    def set_infrared_channel(self,
                             infrared_sensor: typing.Optional[
                                 _infrared_sensor.InfraredSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    def has_image_sensor(self) -> bool:
        """
        Returns if this packet has an image channel.
        :return: If this packlet has an image channel.
        """
        return self._has_channel(api900_pb2.IMAGE)

    def image_sensor(self) -> typing.Optional[_image_sensor.ImageSensor]:
        """
        Returns the high-level image channel API or None if this packet doesn't contain a channel of this type.
        :return: the high-level image channel API or None if this packet doesn't contain a channel of this type.
        """
        if self.has_image_sensor():
            return _image_sensor.ImageSensor(self._get_channel(api900_pb2.IMAGE))

        return None

    def set_image_sensor(self, image_sensor: typing.Optional[_image_sensor.ImageSensor]) -> 'WrappedRedvoxPacket':
        """
        Set's the image channel.
        :param image_sensor: Image sensor.
        """
        if self.has_image_sensor():
            self._delete_channel(api900_pb2.IMAGE)

        if image_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(image_sensor._unevenly_sampled_channel)

        return self

    @deprecation.deprecated("2.0.0", has_image_sensor)
    def has_image_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", image_sensor)
    def image_channel(self) -> typing.Optional[_image_sensor.ImageSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_image_sensor)
    def set_image_channel(self, image_sensor: typing.Optional[_image_sensor.ImageSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    def __str__(self):
        """
        Returns protobuf's String representation of this packet.
        :return: Protobuf's String representation of this packet.
        """
        return str(self._redvox_packet)

    def __eq__(self, other):
        return isinstance(other, WrappedRedvoxPacket) and len(self.diff(other)) == 0

    def diff(self, other: 'WrappedRedvoxPacket') -> typing.List[str]:
        """
        Finds the differences (if any) between two WrappedRedvoxPackets.
        :param other: The other wrapped redvox packet to compare to.
        :return: A list of differences or an empty list if there are none.
        """
        diffs = map(lambda tuple2: reader_utils.diff(tuple2[0], tuple2[1]), [
            (self.api(), other.api()),
            (self.redvox_id(), other.redvox_id()),
            (self.uuid(), other.uuid()),
            (self.authenticated_email(), other.authenticated_email()),
            (self.authentication_token(), other.authentication_token()),
            (self.firebase_token(), other.firebase_token()),
            (self.is_backfilled(), other.is_backfilled()),
            (self.is_private(), other.is_private()),
            (self.is_scrambled(), other.is_scrambled()),
            (self.device_make(), other.device_make()),
            (self.device_model(), other.device_model()),
            (self.device_os(), other.device_os()),
            (self.device_os_version(), other.device_os_version()),
            (self.app_version(), other.app_version()),
            (self.battery_level_percent(), other.battery_level_percent()),
            (self.device_temperature_c(), other.device_temperature_c()),
            (self.acquisition_server(), other.acquisition_server()),
            (self.time_synchronization_server(), other.time_synchronization_server()),
            (self.authentication_server(), other.authentication_server()),
            (self.app_file_start_timestamp_epoch_microseconds_utc(),
             other.app_file_start_timestamp_epoch_microseconds_utc()),
            (self.app_file_start_timestamp_machine(), other.app_file_start_timestamp_machine()),
            (self.server_timestamp_epoch_microseconds_utc(),
             other.server_timestamp_epoch_microseconds_utc()),
            (self.metadata(), other.metadata()),
            (self.microphone_sensor(), other.microphone_sensor()),
            (self.barometer_sensor(), other.barometer_sensor()),
            (self.location_sensor(), other.location_sensor()),
            (self.time_synchronization_sensor(), other.time_synchronization_sensor()),
            (self.accelerometer_sensor(), other.accelerometer_sensor()),
            (self.magnetometer_sensor(), other.magnetometer_sensor()),
            (self.gyroscope_sensor(), other.gyroscope_sensor()),
            (self.light_sensor(), other.light_sensor()),
            (self.infrared_sensor(), other.infrared_sensor())
        ])
        # Filter only out only the differences
        diffs = filter(lambda tuple2: tuple2[0], diffs)
        # Extract the difference string
        diffs = map(lambda tuple2: tuple2[1], diffs)
        return list(diffs)
</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" class="name">class <span class="ident">WrappedRedvoxPacket</span></p>
      
  
    <div class="desc"><p>This class provides convenience methods for accessing API 900 protobuf redvox packets.</p>
<p>This packet contains a reference to the original packet which should be used to access all "top-level" fields. For
accessing channels, this class can search for and return our high-level channel wrappers or can extract the payload
directly.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket" class="source">
    <pre><code>class WrappedRedvoxPacket:
    """
    This class provides convenience methods for accessing API 900 protobuf redvox packets.

    This packet contains a reference to the original packet which should be used to access all "top-level" fields. For
    accessing channels, this class can search for and return our high-level channel wrappers or can extract the payload
    directly.
    """

    def __init__(self, redvox_packet: api900_pb2.RedvoxPacket = None):
        """
        Initializes this wrapped redvox packet.
        :param redvox_packet: A protobuf redvox packet.
        """
        if redvox_packet is None:
            self._redvox_packet = api900_pb2.RedvoxPacket()
            self._evenly_sampled_channels_field = list()
            self._unevenly_sampled_channels_field = list()
            self._metadata_list = list()
            self._channel_cache = {}

        else:
            self._redvox_packet: api900_pb2.RedvoxPacket = redvox_packet
            """Protobuf api 900 redvox packet"""

            self._evenly_sampled_channels_field: typing.List[EvenlySampledChannel] = list(
                map(EvenlySampledChannel, reader_utils.repeated_to_array(redvox_packet.evenly_sampled_channels)))
            """List of evenly sampled channels"""

            self._unevenly_sampled_channels_field: typing.List[UnevenlySampledChannel] = list(
                map(UnevenlySampledChannel,
                    reader_utils.repeated_to_array(redvox_packet.unevenly_sampled_channels)))
            """List of unevenly sampled channels"""

            self._metadata_list: typing.List[str] = reader_utils.repeated_to_list(redvox_packet.metadata)
            """List of metadata"""

            self._channel_cache: typing.Dict[int, typing.Union[EvenlySampledChannel, UnevenlySampledChannel]] = {}
            """Holds a mapping of channel type to channel for O(1) access."""

            # Initialize channel cache
            for evenly_sampled_channel in self._evenly_sampled_channels_field:
                for channel_type in evenly_sampled_channel.channel_types:
                    self._channel_cache[channel_type] = evenly_sampled_channel

            for unevenly_sampled_channel in self._unevenly_sampled_channels_field:
                for channel_type in unevenly_sampled_channel.channel_types:
                    self._channel_cache[channel_type] = unevenly_sampled_channel

    def redvox_packet(self) -> api900_pb2.RedvoxPacket:
        """
        returns the protobuf redvox packet
        :return: protobuf redvox packet
        """
        return self._redvox_packet

    def _evenly_sampled_channels(self) -> typing.List[EvenlySampledChannel]:
        """
        returns the evenly sampled channels as a copied list to avoid built in functions making untracked changes
        :return: list of evenly sampled channels
        """
        return self._evenly_sampled_channels_field.copy()

    def _unevenly_sampled_channels(self) -> typing.List[UnevenlySampledChannel]:
        """
        returns the unevenly sampled channels as a copied list to avoid built in functions making untracked changes
        :return: list of unevenly sampled channels
        """
        return self._unevenly_sampled_channels_field.copy()

    def _refresh_channels(self):
        """
        takes the redvox packet and rebuilds the channel cache from it
        """
        self._evenly_sampled_channels_field = list(map(EvenlySampledChannel,
                                                       reader_utils.repeated_to_array(
                                                           self._redvox_packet.evenly_sampled_channels)))
        self._unevenly_sampled_channels_field = list(map(UnevenlySampledChannel,
                                                         reader_utils.repeated_to_array(
                                                             self._redvox_packet.unevenly_sampled_channels)))
        self._channel_cache = {}
        for evenly_sampled_channel in self._evenly_sampled_channels_field:
            for channel_type in evenly_sampled_channel.channel_types:
                self._channel_cache[channel_type] = evenly_sampled_channel
        for unevenly_sampled_channel in self._unevenly_sampled_channels_field:
            for channel_type in unevenly_sampled_channel.channel_types:
                self._channel_cache[channel_type] = unevenly_sampled_channel

    def _add_channel(self, channel: typing.Union[EvenlySampledChannel, UnevenlySampledChannel]):
        """
        Add a channel
        :param channel: channel to add
        """
        index, sample = self._find_channel(channel.channel_types[0])
        if index is None and sample is None:
            # if type(channel) not in [EvenlySampledChannel, UnevenlySampledChannel]:
            if not isinstance(channel, (EvenlySampledChannel, UnevenlySampledChannel)):
                raise TypeError("Channel type to add must be even or uneven.")
            else:
                self._add_channel_redvox_packet(channel)
                self._refresh_channels()
        else:
            raise ValueError("Cannot add a channel with a type that already exists in this packet.")

    def _edit_channel(self, channel_type: int, channel: typing.Union[EvenlySampledChannel, UnevenlySampledChannel]):
        """
        removes the channel with the given type and adds the channel supplied
        :param channel_type: type of channel to remove
        :param channel: the channel to add
        """
        index, sampling = self._find_channel(channel_type)
        if index is not None and sampling is not None:
            if isinstance(channel, EvenlySampledChannel):
                del self._redvox_packet.evenly_sampled_channels[index]
                self._add_channel_redvox_packet(channel)
            elif isinstance(channel, UnevenlySampledChannel):
                del self._redvox_packet.unevenly_sampled_channels[index]
                self._add_channel_redvox_packet(channel)
            else:
                raise TypeError("Channel type to edit is unknown!")
            self._refresh_channels()
        else:
            raise TypeError("Unknown channel type specified for edit.")

    def _delete_channel(self, channel_type: int):
        """
        deletes the channel type specified
        :param channel_type: a channel to remove
        """
        index, sampling = self._find_channel(channel_type)
        if index is not None and sampling is not None:
            if sampling == EvenlySampledChannel:
                del self._redvox_packet.evenly_sampled_channels[index]
            else:
                del self._redvox_packet.unevenly_sampled_channels[index]
            self._refresh_channels()
        else:
            raise TypeError("Unknown channel type to remove from packet.")

    # pylint: disable=W0120
    def _find_channel(self, channel_type: int) -> (int, typing.Union[EvenlySampledChannel, UnevenlySampledChannel]):
        """
        returns the index of the channel and the kind of sampled array its in
        :return: the index in the even or uneven array and the name of the array
        """
        if self._has_channel(channel_type):
            for idx in range(len(self._evenly_sampled_channels_field)):
                if channel_type in self._evenly_sampled_channels_field[idx].channel_types:
                    return idx, EvenlySampledChannel
            for idx in range(len(self._unevenly_sampled_channels_field)):
                if channel_type in self._unevenly_sampled_channels_field[idx].channel_types:
                    return idx, UnevenlySampledChannel
            else:
                return None, None
        else:
            return None, None

    # pylint: disable=R0912
    def _add_channel_redvox_packet(self, channel: typing.Union[EvenlySampledChannel, UnevenlySampledChannel]):
        """
        adds the channel to the redvox_packet
        :param channel: channel to add
        """
        if isinstance(channel, EvenlySampledChannel):
            newchan = self._redvox_packet.evenly_sampled_channels.add()
            newchan.sample_rate_hz = channel.sample_rate_hz
            newchan.first_sample_timestamp_epoch_microseconds_utc = \
                channel.first_sample_timestamp_epoch_microseconds_utc
        elif isinstance(channel, UnevenlySampledChannel):
            newchan = self._redvox_packet.unevenly_sampled_channels.add()
            for time in channel.timestamps_microseconds_utc:
                newchan.timestamps_microseconds_utc.append(time)
            newchan.sample_interval_mean = channel.sample_interval_mean
            newchan.sample_interval_std = channel.sample_interval_std
            newchan.sample_interval_median = channel.sample_interval_median
        else:
            raise TypeError("Channel type to add to redvox packet is unknown!")

        pl_type = channel.get_payload_type()
        if pl_type == "byte_payload":
            newchan.byte_payload.payload.extend(channel.payload)
        elif pl_type == "uint32_payload":
            newchan.uint32_payload.payload.extend(channel.payload)
        elif pl_type == "uint64_payload":
            newchan.uint64_payload.payload.extend(channel.payload)
        elif pl_type == "int32_payload":
            newchan.int32_payload.payload.extend(channel.payload)
        elif pl_type == "int64_payload":
            newchan.int64_payload.payload.extend(channel.payload)
        elif pl_type == "float32_payload":
            newchan.float32_payload.payload.extend(channel.payload)
        elif pl_type == "float64_payload":
            newchan.float64_payload.payload.extend(channel.payload)
        elif pl_type is None:
            pass
        else:
            raise TypeError("Unknown payload type in channel to add.")

        for chan_type in channel.channel_types:
            newchan.channel_types.append(chan_type)
        newchan.sensor_name = channel.sensor_name
        for mean in channel.value_means:
            newchan.value_means.append(mean)
        for stds in channel.value_stds:
            newchan.value_stds.append(stds)
        for median in channel.value_medians:
            newchan.value_medians.append(median)
        for meta in channel.metadata:
            newchan.metadata.append(meta)

    def _get_channel_types(self) -> typing.List[typing.List[int]]:
        """
        Returns a list of channel type enumerations. This is a list of lists, and allows us to easily view
        interleaved channels.
        :return: A list of channel type enumerations.
        """
        channel_types = []
        for evenly_sampled_channel in self._evenly_sampled_channels_field:
            channel_types.append(evenly_sampled_channel.channel_types)

        for unevenly_sampled_channel in self._unevenly_sampled_channels_field:
            channel_types.append(unevenly_sampled_channel.channel_types)

        return channel_types

    def _get_channel_type_names(self) -> typing.List[typing.List[str]]:
        """
        Returns a list of channel type names. This is a list of lists, and allows us to easily view
        interleaved channels.
        :return: A list of channel type names. This is a list of lists, and allows us to easily view
        interleaved channels.
        """
        names = []
        for channel_types in self._get_channel_types():
            names.append(list(map(reader_utils.channel_type_name_from_enum, channel_types)))
        return names

    def _get_channel(self, channel_type: int) -> typing.Union[EvenlySampledChannel, UnevenlySampledChannel, None]:
        """
        Returns a channel from this packet according to the channel type.
        :param channel_type: The channel type to search for.
        :return: A high level channel wrapper or None.
        """
        if channel_type in self._channel_cache:
            return self._channel_cache[channel_type]

        return None

    def _has_channel(self, channel_type: int) -> bool:
        """
        Returns True if this packet contains a channel with this type otherwise False.
        :param channel_type: Channel type to search for.
        :return: True is this packet contains a channel with this type otherwise False.
        """
        return channel_type in self._channel_cache

    def _has_channels(self, channel_types: typing.List[int]) -> bool:
        """
        Checks that this packet contains all of the provided channels.
        :param channel_types: Channel types that this packet must contain.
        :return: True if this packet contains all provided channel types, False otherwise.
        """
        has_channel_results = map(self._has_channel, channel_types)
        for has_channel_result in has_channel_results:
            if not has_channel_result:
                return False
        return True

    def to_json(self) -> str:
        """
        Converts the protobuf packet stored in this wrapped packet to JSON.
        :return: The JSON representation of the protobuf encoded packet.
        """
        return reader_utils.to_json(self._redvox_packet)

    def compressed_buffer(self) -> bytes:
        """
        Returns the compressed buffer associated with this packet.
        :return: The compressed buffer associated with this packet.
        """
        return reader_utils.lz4_compress(self._redvox_packet.SerializeToString())

    def default_filename(self, extension: str = "rdvxz") -> str:
        """
        Constructs a default filename from the packet's metadata.
        :param extension: An optional extension to use.
        :return: A default filename from the packet's metadata.
        """
        return "%s_%d.%s" % (self.redvox_id(), int(round(self.app_file_start_timestamp_machine() / 1000.0)), extension)

    def write_rdvxz(self, directory: str, filename: typing.Optional[str] = None):
        """
        Writes a compressed .rdvxz file to the specified directory.
        :param directory: The directory to write the file to.
        :param filename: An optional filename (the default filename will be used if one is not provided).
        """
        filename = self.default_filename() if filename is None else filename
        path = os.path.join(directory, filename)
        with open(path, "wb") as rdvxz_out:
            rdvxz_out.write(self.compressed_buffer())

    def write_json(self, directory: str, filename: typing.Optional[str] = None):
        """
        Writes a RedVox compliant .json file to the specified directory.
        :param directory: The directory to write the file to.
        :param filename: An optional filename (the default filename will be used if one is not provided).
        """
        filename = self.default_filename(extension="json") if filename is None else filename
        path = os.path.join(directory, filename)
        with open(path, "w") as json_out:
            json_out.write(self.to_json())

    def clone(self) -> 'WrappedRedvoxPacket':
        """
        Returns a clone of this WrappedRedvoxPacket.
        :return: A clone of this WrappedRedvoxPacket.
        """
        return redvox.api900.reader.read_rdvxz_buffer(self.compressed_buffer())

    def concat(self, wrapped_redvox_packets: typing.List['WrappedRedvoxPacket']) -> typing.List['WrappedRedvoxPacket']:
        """
        Concatenates this packet with other packets.
        :param wrapped_redvox_packets: Other packets to concatenate with this packet.
        :return: A list of packets each containing a continuous set of data.
        """
        return redvox.api900.concat.concat_wrapped_redvox_packets([self] + wrapped_redvox_packets)

    # Start of packet level API getters and setters
    def api(self) -> int:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.api

    def set_api(self, version: int) -> 'WrappedRedvoxPacket':
        """
        sets the api version number
        :param version: version number
        """
        self._redvox_packet.api = version
        return self

    def uuid(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.uuid

    def set_uuid(self, uid: str) -> 'WrappedRedvoxPacket':
        """
        sets the uuid
        :param uid: uuid string
        """
        self._redvox_packet.uuid = uid
        return self

    def redvox_id(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.redvox_id

    def set_redvox_id(self, rid: str) -> 'WrappedRedvoxPacket':
        """
        sets the redvox id
        :param rid: redvox id string
        """
        self._redvox_packet.redvox_id = rid
        return self

    def authenticated_email(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.authenticated_email

    def set_authenticated_email(self, email: str) -> 'WrappedRedvoxPacket':
        """
        sets the authenticated email
        :param email: authenticated email string
        """
        self._redvox_packet.authenticated_email = email
        return self

    def authentication_token(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.authentication_token

    def set_authentication_token(self, token: str) -> 'WrappedRedvoxPacket':
        """
        sets the authentication token
        :param token: authentication token string
        """
        self._redvox_packet.authentication_token = token
        return self

    def firebase_token(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.firebase_token

    def set_firebase_token(self, token: str) -> 'WrappedRedvoxPacket':
        """
        sets the firebase token
        :param token: firebase token string
        """
        self._redvox_packet.firebase_token = token
        return self

    def is_backfilled(self) -> bool:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.is_backfilled

    def set_is_backfilled(self, tof: bool) -> 'WrappedRedvoxPacket':
        """
        sets the is_backfilled flag
        :param tof: true or false
        """
        self._redvox_packet.is_backfilled = tof
        return self

    def is_private(self) -> bool:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.is_private

    def set_is_private(self, tof: bool) -> 'WrappedRedvoxPacket':
        """
        sets the is_private flag
        :param tof: true or false
        """
        self._redvox_packet.is_private = tof
        return self

    def is_scrambled(self) -> bool:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.is_scrambled

    def set_is_scrambled(self, tof: bool) -> 'WrappedRedvoxPacket':
        """
        sets the is_scrambled flag
        :param tof: true or false
        """
        self._redvox_packet.is_scrambled = tof
        return self

    def device_make(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.device_make

    def set_device_make(self, make: str) -> 'WrappedRedvoxPacket':
        """
        sets the make of the device
        :param make: make of the device string
        """
        self._redvox_packet.device_make = make
        return self

    def device_model(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.device_model

    def set_device_model(self, model: str) -> 'WrappedRedvoxPacket':
        """
        sets the model of the device
        :param model: model of the device string
        """
        self._redvox_packet.device_model = model
        return self

    def device_os(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.device_os

    def set_device_os(self, device_os: str) -> 'WrappedRedvoxPacket':
        """
        sets the device operating system
        :param device_os: operating system string
        """
        self._redvox_packet.device_os = device_os
        return self

    def device_os_version(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.device_os_version

    def set_device_os_version(self, version: str) -> 'WrappedRedvoxPacket':
        """
        sets the device OS version
        :param version: device OS version string
        """
        self._redvox_packet.device_os_version = version
        return self

    def app_version(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.app_version

    def set_app_version(self, version: str) -> 'WrappedRedvoxPacket':
        """
        sets the app version number
        :param version: app version string
        """
        self._redvox_packet.app_version = version
        return self

    def battery_level_percent(self) -> float:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.battery_level_percent

    def set_battery_level_percent(self, percent: float) -> 'WrappedRedvoxPacket':
        """
        sets the percentage of battery left
        :param percent: percentage of battery left
        """
        self._redvox_packet.battery_level_percent = percent
        return self

    def device_temperature_c(self) -> float:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.device_temperature_c

    def set_device_temperature_c(self, temp: float) -> 'WrappedRedvoxPacket':
        """
        sets the device temperature in degrees Celsius
        :param temp: temperature in degrees Celsius
        """
        self._redvox_packet.device_temperature_c = temp
        return self

    def acquisition_server(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.acquisition_server

    def set_acquisition_server(self, server: str) -> 'WrappedRedvoxPacket':
        """
        sets the acquisition server url
        :param server: url to acquisition server
        """
        self._redvox_packet.acquisition_server = server
        return self

    # pylint: disable=invalid-name
    def time_synchronization_server(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.time_synchronization_server

    def set_time_synchronization_server(self, server: str) -> 'WrappedRedvoxPacket':
        """
        sets the time synchronization server url
        :param server: url to time synchronization server
        """
        self._redvox_packet.time_synchronization_server = server
        return self

    def authentication_server(self) -> str:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.authentication_server

    def set_authentication_server(self, server: str) -> 'WrappedRedvoxPacket':
        """
        sets the authentication server url
        :param server: url to authentication server
        """
        self._redvox_packet.authentication_server = server
        return self

    # pylint: disable=invalid-name
    def app_file_start_timestamp_epoch_microseconds_utc(self) -> int:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.app_file_start_timestamp_epoch_microseconds_utc

    def set_app_file_start_timestamp_epoch_microseconds_utc(self, time: int) -> 'WrappedRedvoxPacket':
        """
        sets the timestamp of packet creation
        :param time: time when packet was created in microseconds since utc epoch
        """
        self._redvox_packet.app_file_start_timestamp_epoch_microseconds_utc = time
        return self

    # pylint: disable=invalid-name
    def app_file_start_timestamp_machine(self) -> int:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.app_file_start_timestamp_machine

    def set_app_file_start_timestamp_machine(self, time: int) -> 'WrappedRedvoxPacket':
        """
        sets the internal machine timestamp of packet creation
        :param time: time when packet was created on local machine
        """
        self._redvox_packet.app_file_start_timestamp_machine = time
        return self

    # pylint: disable=invalid-name
    def server_timestamp_epoch_microseconds_utc(self) -> int:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._redvox_packet.server_timestamp_epoch_microseconds_utc

    def set_server_timestamp_epoch_microseconds_utc(self, time: int) -> 'WrappedRedvoxPacket':
        """
        sets the server timestamp when the packet was received
        :param time: time when packet was received by server
        """
        self._redvox_packet.server_timestamp_epoch_microseconds_utc = time
        return self

    def metadata(self) -> typing.List[str]:
        """
        See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
        description of this field.
        """
        return self._metadata_list

    def set_metadata(self, data: typing.List[str]) -> 'WrappedRedvoxPacket':
        """
        sets the metadata
        :param data: metadata as list of strings
        """
        self._metadata_list = data
        self._redvox_packet.metadata[:] = data
        return self

    def _clear_metadata(self):
        """
        removes all of the packet level metadata from packet
        """
        del self._redvox_packet.metadata[:]
        self._metadata_list.clear()

    def metadata_as_dict(self) -> typing.Dict[str, str]:
        """
        Return this packet's metadata as a key-value Python dictionary.
        :return: This packet's metadata as a key-value Python dictionary.
        """
        return reader_utils.get_metadata_as_dict(self._metadata_list)

    def set_metadata_as_dict(self, metadata_dict: typing.Dict[str, str]) -> 'WrappedRedvoxPacket':
        """
        Sets the metadata using a dictionary.
        :param metadata_dict: Dictionary of metadata.
        :return: This WrappedRedvoxPacket.
        """
        self.set_metadata(reader_utils.metadata_dict_to_list(metadata_dict))
        return self

    def add_metadata(self, key: str, value: str) -> 'WrappedRedvoxPacket':
        """
        Adds a key pair value to the metadata.
        :param key: The key.
        :param value: The value.
        :return: This instance of a WrappedRedvoxPacket.
        """
        metadata = self.metadata_as_dict()
        metadata[key] = value if isinstance(value, str) else str(value)
        self.set_metadata_as_dict(metadata)
        return self

    def start_timestamp_us_utc(self) -> int:
        """
        Returns the start timestamp of a WrappedRedvoxPacket.
        :return: The start timestamp of a WrappedRedvoxPacket.
        """
        return self.microphone_sensor().first_sample_timestamp_epoch_microseconds_utc()

    def duration_s(self) -> float:
        """
        The duration of this WrappedRedvoxPacket in seconds.
        :return: The duration of this WrappedRedvoxPacket in seconds.
        """
        microphone_sensor = self.microphone_sensor()
        return len(microphone_sensor.payload_values()) / microphone_sensor.sample_rate_hz()

    def end_timestamp_us_utc(self):
        """
        Returns the end timestamp of a WrappedRedvoxPacket.
        :return: The end timestamp of a WrappedRedvoxPacket.
        """
        return self.start_timestamp_us_utc() + date_time_utils.seconds_to_microseconds(self.duration_s())

    def update_uneven_sensor_timestamps(self, time_delta: int or float):
        """
        Given a time delta in microseconds, will adjust all unevenly sampled sensor timestamps by that amount.
        Use negative values to adjust backwards in time.
        :param time_delta: amount of time to adjust timestamps in microseconds
        """
        for channel in self._unevenly_sampled_channels_field:
            if not channel.has_channel(api900_pb2.TIME_SYNCHRONIZATION):
                channel.set_timestamps_microseconds_utc(channel.timestamps_microseconds_utc + time_delta)

    def mach_time_zero(self) -> typing.Optional[int]:
        """
        Returns the mach time zero from the metadata if it exists.
        :return: The mach time zero from the metadata if it exists.
        """
        try:
            return int(self.metadata_as_dict()["machTimeZero"])
        except (KeyError, ValueError):
            return None

    def set_mach_time_zero(self, mach_time_zero: int) -> 'WrappedRedvoxPacket':
        """
        Sets the mach time zero in the packet's metadata.
        :param mach_time_zero: The mach time zero to use.
        :return: An instance of this wrapped packet.
        """
        return self.add_metadata("machTimeZero", str(mach_time_zero))

    def best_latency(self) -> typing.Optional[float]:
        """
        Returns the best latency from the metadata if it exists.
        :return: The best latency from the metadata if it exists.
        """
        try:
            return float(self.metadata_as_dict()["bestLatency"])
        except (KeyError, ValueError):
            return None

    def set_best_latency(self, best_latency: float) -> 'WrappedRedvoxPacket':
        """
        Sets the best latency in the packet's metadata.
        :param best_latency: The best latency to use.
        :return: An instance of this wrapped packet.
        """
        return self.add_metadata("bestLatency", str(best_latency))

    def best_offset(self) -> typing.Optional[float]:
        """
        Returns the best offset from the metadata if it exists.
        :return: The best offset from the metadata if it exists.
        """
        try:
            return float(self.metadata_as_dict()["bestOffset"])
        except (KeyError, ValueError):
            return None

    def set_best_offset(self, best_offset: float) -> 'WrappedRedvoxPacket':
        """
        Sets the best offset in the packet's metadata.
        :param best_offset: The best offset to use.
        :return: An instance of this wrapped packet.
        """
        return self.add_metadata("bestOffset", str(best_offset))

    def is_synch_corrected(self) -> bool:
        """
        Returns the isSynchCorrected value from the metadata if it exists.
        :return: The isSynchCorrected value from the metadata if it exists.
        """

        def _parse_bool(s: str) -> bool:
            return s == "true" or s == "True"

        try:
            return _parse_bool(self.metadata_as_dict()["isSynchCorrected"])
        except (KeyError, ValueError):
            return False

    def set_is_synch_corrected(self, is_synch_corrected: bool) -> 'WrappedRedvoxPacket':
        """
        Sets the is_synch_corrected field in the packet's metadata.
        :param is_synch_corrected: The is_synch_corrected field to use.
        :return: An instance of this wrapped packet.
        """
        return self.add_metadata("isSynchCorrected", "true" if is_synch_corrected else "false")

    # Sensor channels
    def has_microphone_sensor(self) -> bool:
        """
        Returns if this packet has a microphone channel.
        :return: If this packet has a microphone channel.
        """
        return self._has_channel(api900_pb2.MICROPHONE)

    def microphone_sensor(self) -> typing.Optional[_microphone_sensor.MicrophoneSensor]:
        """
        Returns the high-level microphone channel API or None if this packet doesn't contain a channel of this type.
        :return: the high-level microphone channel API or None if this packet doesn't contain a channel of this type.
        """
        if self.has_microphone_sensor():
            return _microphone_sensor.MicrophoneSensor(self._get_channel(api900_pb2.MICROPHONE))

        return None

    def set_microphone_sensor(self, microphone_sensor: typing.Optional[
            _microphone_sensor.MicrophoneSensor]) -> 'WrappedRedvoxPacket':
        """
        Sets this packets microphone sensor. A channel can be removed by passing in None.
        :param microphone_sensor: An optional instance of a microphone sensor.
        :return: This instance of a wrapped redvox packet.
        """
        if self.has_microphone_sensor():
            self._delete_channel(api900_pb2.MICROPHONE)

        if microphone_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(microphone_sensor._evenly_sampled_channel)

        return self

    @deprecation.deprecated("2.0.0", has_microphone_sensor)
    def has_microphone_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", microphone_sensor)
    def microphone_channel(self) -> typing.Optional[_microphone_sensor.MicrophoneSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_microphone_sensor)
    def set_microphone_channel(self, microphone_sensor: typing.Optional[
            _microphone_sensor.MicrophoneSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    def has_barometer_sensor(self) -> bool:
        """
        Returns if this packet has a barometer channel.
        :return: If this packet has a barometer channel.
        """
        return self._has_channel(api900_pb2.BAROMETER)

    def barometer_sensor(self) -> typing.Optional[_barometer_sensor.BarometerSensor]:
        """
        Returns the high-level barometer channel API or None if this packet doesn't contain a channel of this type.
        :return: the high-level barometer channel API or None if this packet doesn't contain a channel of this type.
        """
        if self.has_barometer_sensor():
            return _barometer_sensor.BarometerSensor(self._get_channel(api900_pb2.BAROMETER))

        return None

    def set_barometer_sensor(self, barometer_sensor: typing.Optional[
            _barometer_sensor.BarometerSensor]) -> 'WrappedRedvoxPacket':
        """
        Sets this packets barometer sensor. A channel can be removed by passing in None.
        :param barometer_sensor: An optional instance of a barometer sensor.
        :return: This instance of a wrapped redvox packet.
        """
        if self.has_barometer_sensor():
            self._delete_channel(api900_pb2.BAROMETER)

        if barometer_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(barometer_sensor._unevenly_sampled_channel)

        return self

    @deprecation.deprecated("2.0.0", barometer_sensor)
    def barometer_channel(self) -> typing.Optional[_barometer_sensor.BarometerSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", has_barometer_sensor)
    def has_barometer_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_barometer_sensor)
    def set_barometer_channel(self, barometer_sensor: typing.Optional[
            _barometer_sensor.BarometerSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    def has_location_sensor(self) -> bool:
        """
        Returns if this packet has a location channel.
        :return: If this packet has a location channel.
        """
        return (self._has_channels(
            [api900_pb2.LATITUDE, api900_pb2.LONGITUDE, api900_pb2.ALTITUDE, api900_pb2.SPEED,
             api900_pb2.ACCURACY]) or self._has_channels([api900_pb2.LATITUDE, api900_pb2.LONGITUDE]))

    def location_sensor(self) -> typing.Optional[_location_sensor.LocationSensor]:
        """
        Returns the high-level location channel API or None if this packet doesn't contain a channel of this type.
        :return: the high-level location channel API or None if this packet doesn't contain a channel of this type.
        """
        if self.has_location_sensor():
            return _location_sensor.LocationSensor(self._get_channel(api900_pb2.LATITUDE))

        return None

    def set_location_sensor(self,
                            location_sensor: typing.Optional[_location_sensor.LocationSensor]) -> 'WrappedRedvoxPacket':
        """
        Sets this packet's location sensor. A channel can be removed by passing in None.
        :param location_sensor: An optional instance of a location sensor.
        :return: This instance of a wrapped redvox packet.
        """
        if self.has_location_sensor():
            self._delete_channel(api900_pb2.LATITUDE)

        if location_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(location_sensor._unevenly_sampled_channel)

        return self

    @deprecation.deprecated("2.0.0", has_location_sensor)
    def has_location_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", location_sensor)
    def location_channel(self) -> typing.Optional[_location_sensor.LocationSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_location_sensor)
    def set_location_channel(self,
                             location_sensor: typing.Optional[
                                 _location_sensor.LocationSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    # pylint: disable=invalid-name,C1801
    def has_time_synchronization_sensor(self) -> bool:
        """
        Returns if this packet has a time synchronization channel.
        :return: If this packet has a time synchronization channel.
        """
        if self._has_channel(api900_pb2.TIME_SYNCHRONIZATION):
            ch = _time_synchronization_sensor.TimeSynchronizationSensor(
                self._get_channel(api900_pb2.TIME_SYNCHRONIZATION))
            return len(ch.payload_values()) > 0

        return False

    def time_synchronization_sensor(self) -> typing.Optional[_time_synchronization_sensor.TimeSynchronizationSensor]:
        """
        Returns the high-level time synchronization channel API or None if this packet doesn't contain a channel of
        this type.
        :return: the high-level time synchronization channel API or None if this packet doesn't contain a channel of
        this type.
        """
        if self.has_time_synchronization_sensor():
            return _time_synchronization_sensor.TimeSynchronizationSensor(
                self._get_channel(api900_pb2.TIME_SYNCHRONIZATION))

        return None

    def set_time_synchronization_sensor(self, time_synchronization_sensor: typing.Optional[
            _time_synchronization_sensor.TimeSynchronizationSensor]) -> 'WrappedRedvoxPacket':
        """
        Sets this packet's time sync sensor. A channel can be removed by passing in None.
        :param time_synchronization_sensor: An optional instance of a time sync sensor.
        :return: This instance of a wrapped redvox packet.
        """
        if self.has_time_synchronization_sensor():
            self._delete_channel(api900_pb2.TIME_SYNCHRONIZATION)

        if time_synchronization_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(time_synchronization_sensor._unevenly_sampled_channel)

        return self

    # pylint: disable=invalid-name,C1801
    @deprecation.deprecated("2.0.0", has_time_synchronization_sensor)
    def has_time_synchronization_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", time_synchronization_sensor)
    def time_synchronization_channel(self) -> typing.Optional[_time_synchronization_sensor.TimeSynchronizationSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_time_synchronization_sensor)
    def set_time_synchronization_channel(self, time_synchronization_sensor: typing.Optional[
            _time_synchronization_sensor.TimeSynchronizationSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    def has_accelerometer_sensor(self) -> bool:
        """
        Returns if this packet has an accelerometer channel.
        :return: If this packet has an accelerometer channel.
        """
        return self._has_channels([api900_pb2.ACCELEROMETER_X, api900_pb2.ACCELEROMETER_Y, api900_pb2.ACCELEROMETER_Z])

    def accelerometer_sensor(self) -> typing.Optional[_accelerometer_sensor.AccelerometerSensor]:
        """
        Returns the high-level accelerometer channel API or None if this packet doesn't contain a channel of this type.
        :return: the high-level accelerometer channel API or None if this packet doesn't contain a channel of this type.
        """
        if self.has_accelerometer_sensor():
            return _accelerometer_sensor.AccelerometerSensor(self._get_channel(api900_pb2.ACCELEROMETER_X))

        return None

    def set_accelerometer_sensor(self,
                                 accelerometer_sensor: typing.Optional[
                                     _accelerometer_sensor.AccelerometerSensor]) -> 'WrappedRedvoxPacket':
        """
        Sets this packet's accelerometer sensor. A channel can be removed by passing in None.
        :param accelerometer_sensor: An optional instance of a accelerometer sensor.
        """
        if self.has_accelerometer_sensor():
            self._delete_channel(api900_pb2.ACCELEROMETER_X)

        if accelerometer_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(accelerometer_sensor._unevenly_sampled_channel)

        return self

    @deprecation.deprecated("2.0.0", has_accelerometer_sensor)
    def has_accelerometer_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", accelerometer_sensor)
    def accelerometer_channel(self) -> typing.Optional[_accelerometer_sensor.AccelerometerSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_accelerometer_sensor)
    def set_accelerometer_channel(self,
                                  accelerometer_sensor: typing.Optional[
                                      _accelerometer_sensor.AccelerometerSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    def has_magnetometer_sensor(self) -> bool:
        """
        Returns if this packet has a magnetometer channel.
        :return: If this packet has a magnetometer channel.
        """
        return self._has_channels([api900_pb2.MAGNETOMETER_X, api900_pb2.MAGNETOMETER_Y, api900_pb2.MAGNETOMETER_Z])

    def magnetometer_sensor(self) -> typing.Optional[_magnetometer_sensor.MagnetometerSensor]:
        """
        Returns the high-level magnetometer channel API or None if this packet doesn't contain a channel of this type.
        :return: the high-level magnetometer channel API or None if this packet doesn't contain a channel of this type.
        """
        if self.has_magnetometer_sensor():
            return _magnetometer_sensor.MagnetometerSensor(self._get_channel(api900_pb2.MAGNETOMETER_X))

        return None

    def set_magnetometer_sensor(self,
                                magnetometer_sensor: typing.Optional[
                                    _magnetometer_sensor.MagnetometerSensor]) -> 'WrappedRedvoxPacket':
        """
        Sets this packet's magnetomer sensor. A channel can be removed by passing in None.
        :param magnetometer_sensor: An optional instance of a magnetometer sensor.
        :return: This instance of a wrapped redvox packet.
        """
        if self.has_magnetometer_sensor():
            self._delete_channel(api900_pb2.MAGNETOMETER_X)

        if magnetometer_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(magnetometer_sensor._unevenly_sampled_channel)

        return self

    @deprecation.deprecated("2.0.0", has_magnetometer_sensor)
    def has_magnetometer_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", magnetometer_sensor)
    def magnetometer_channel(self) -> typing.Optional[_magnetometer_sensor.MagnetometerSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_magnetometer_sensor)
    def set_magnetometer_channel(self,
                                 magnetometer_sensor: typing.Optional[
                                     _magnetometer_sensor.MagnetometerSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    def has_gyroscope_sensor(self) -> bool:
        """
        Returns if this packet has a gyroscope channel.
        :return: If this packet has a gyroscope channel.
        """
        return self._has_channels([api900_pb2.GYROSCOPE_X, api900_pb2.GYROSCOPE_Y, api900_pb2.GYROSCOPE_Z])

    def gyroscope_sensor(self) -> typing.Optional[_gyroscope_sensor.GyroscopeSensor]:
        """
        Returns the high-level gyroscope channel API or None if this packet doesn't contain a channel of this type.
        :return: the high-level gyroscope channel API or None if this packet doesn't contain a channel of this type.
        """
        if self.has_gyroscope_sensor():
            return _gyroscope_sensor.GyroscopeSensor(self._get_channel(api900_pb2.GYROSCOPE_X))

        return None

    def set_gyroscope_sensor(self, gyroscope_sensor: typing.Optional[
            _gyroscope_sensor.GyroscopeSensor]) -> 'WrappedRedvoxPacket':
        """
        Sets this packet's gyroscope sensor. A channel can be removed by passing in None.
        :param gyroscope_sensor: An optional instance of a gyroscope sensor.
        :return: This instance of a wrapped redvox packet.
        """
        if self.has_gyroscope_sensor():
            self._delete_channel(api900_pb2.GYROSCOPE_X)

        if gyroscope_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(gyroscope_sensor._unevenly_sampled_channel)

        return self

    @deprecation.deprecated("2.0.0", has_gyroscope_sensor)
    def has_gyroscope_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", gyroscope_sensor)
    def gyroscope_channel(self) -> typing.Optional[_gyroscope_sensor.GyroscopeSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_gyroscope_sensor)
    def set_gyroscope_channel(self, gyroscope_sensor: typing.Optional[
            _gyroscope_sensor.GyroscopeSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    def has_light_sensor(self) -> bool:
        """
        Returns if this packet has a light channel.
        :return: If this packet has a light channel.
        """
        return self._has_channel(api900_pb2.LIGHT)

    def light_sensor(self) -> typing.Optional[_light_sensor.LightSensor]:
        """
        Returns the high-level light channel API or None if this packet doesn't contain a channel of this type.
        :return: the high-level light channel API or None if this packet doesn't contain a channel of this type.
        """
        if self.has_light_sensor():
            return _light_sensor.LightSensor(self._get_channel(api900_pb2.LIGHT))

        return None

    def set_light_sensor(self, light_sensor: typing.Optional[_light_sensor.LightSensor]) -> 'WrappedRedvoxPacket':
        """
        Sets this packet's light sensor. A channel can be removed by passing in None.
        :param light_sensor: An optional instance of a light sensor.
        :return: This instance of a wrapped redvox packet.
        """
        if self.has_light_sensor():
            self._delete_channel(api900_pb2.LIGHT)

        if light_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(light_sensor._unevenly_sampled_channel)

        return self

    @deprecation.deprecated("2.0.0", has_light_sensor)
    def has_light_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", light_sensor)
    def light_channel(self) -> typing.Optional[_light_sensor.LightSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_light_sensor)
    def set_light_channel(self, light_sensor: typing.Optional[_light_sensor.LightSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    def has_infrared_sensor(self) -> bool:
        """
        Returns if this packet has an infrared channel.
        :return: If this packlet has an infrared channel.
        """
        return self._has_channel(api900_pb2.INFRARED)

    def infrared_sensor(self) -> typing.Optional[_infrared_sensor.InfraredSensor]:
        """
        Returns the high-level infrared channel API or None if this packet doesn't contain a channel of this type.
        :return: the high-level infrared channel API or None if this packet doesn't contain a channel of this type.
        """
        if self.has_infrared_sensor():
            return _infrared_sensor.InfraredSensor(self._get_channel(api900_pb2.INFRARED))

        return None

    def set_infrared_sensor(self,
                            infrared_sensor: typing.Optional[
                                _infrared_sensor.InfraredSensor]) -> 'WrappedRedvoxPacket':
        """
        Sets this packet's infrared sensor. A channel can be removed by passing in None.
        :param infrared_sensor: An optional instance of a infrared sensor.
        """
        if self.has_infrared_sensor():
            self._delete_channel(api900_pb2.INFRARED)

        if infrared_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(infrared_sensor._unevenly_sampled_channel)

        return self

    @deprecation.deprecated("2.0.0", has_infrared_sensor)
    def has_infrared_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", infrared_sensor)
    def infrared_channel(self) -> typing.Optional[_infrared_sensor.InfraredSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_infrared_sensor)
    def set_infrared_channel(self,
                             infrared_sensor: typing.Optional[
                                 _infrared_sensor.InfraredSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    def has_image_sensor(self) -> bool:
        """
        Returns if this packet has an image channel.
        :return: If this packlet has an image channel.
        """
        return self._has_channel(api900_pb2.IMAGE)

    def image_sensor(self) -> typing.Optional[_image_sensor.ImageSensor]:
        """
        Returns the high-level image channel API or None if this packet doesn't contain a channel of this type.
        :return: the high-level image channel API or None if this packet doesn't contain a channel of this type.
        """
        if self.has_image_sensor():
            return _image_sensor.ImageSensor(self._get_channel(api900_pb2.IMAGE))

        return None

    def set_image_sensor(self, image_sensor: typing.Optional[_image_sensor.ImageSensor]) -> 'WrappedRedvoxPacket':
        """
        Set's the image channel.
        :param image_sensor: Image sensor.
        """
        if self.has_image_sensor():
            self._delete_channel(api900_pb2.IMAGE)

        if image_sensor is not None:
            # pylint: disable=W0212
            self._add_channel(image_sensor._unevenly_sampled_channel)

        return self

    @deprecation.deprecated("2.0.0", has_image_sensor)
    def has_image_channel(self) -> bool:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", image_sensor)
    def image_channel(self) -> typing.Optional[_image_sensor.ImageSensor]:
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    @deprecation.deprecated("2.0.0", set_image_sensor)
    def set_image_channel(self, image_sensor: typing.Optional[_image_sensor.ImageSensor]) -> 'WrappedRedvoxPacket':
        """
        This method has been deprecated. See the sensor method equivalent.
        """

    def __str__(self):
        """
        Returns protobuf's String representation of this packet.
        :return: Protobuf's String representation of this packet.
        """
        return str(self._redvox_packet)

    def __eq__(self, other):
        return isinstance(other, WrappedRedvoxPacket) and len(self.diff(other)) == 0

    def diff(self, other: 'WrappedRedvoxPacket') -> typing.List[str]:
        """
        Finds the differences (if any) between two WrappedRedvoxPackets.
        :param other: The other wrapped redvox packet to compare to.
        :return: A list of differences or an empty list if there are none.
        """
        diffs = map(lambda tuple2: reader_utils.diff(tuple2[0], tuple2[1]), [
            (self.api(), other.api()),
            (self.redvox_id(), other.redvox_id()),
            (self.uuid(), other.uuid()),
            (self.authenticated_email(), other.authenticated_email()),
            (self.authentication_token(), other.authentication_token()),
            (self.firebase_token(), other.firebase_token()),
            (self.is_backfilled(), other.is_backfilled()),
            (self.is_private(), other.is_private()),
            (self.is_scrambled(), other.is_scrambled()),
            (self.device_make(), other.device_make()),
            (self.device_model(), other.device_model()),
            (self.device_os(), other.device_os()),
            (self.device_os_version(), other.device_os_version()),
            (self.app_version(), other.app_version()),
            (self.battery_level_percent(), other.battery_level_percent()),
            (self.device_temperature_c(), other.device_temperature_c()),
            (self.acquisition_server(), other.acquisition_server()),
            (self.time_synchronization_server(), other.time_synchronization_server()),
            (self.authentication_server(), other.authentication_server()),
            (self.app_file_start_timestamp_epoch_microseconds_utc(),
             other.app_file_start_timestamp_epoch_microseconds_utc()),
            (self.app_file_start_timestamp_machine(), other.app_file_start_timestamp_machine()),
            (self.server_timestamp_epoch_microseconds_utc(),
             other.server_timestamp_epoch_microseconds_utc()),
            (self.metadata(), other.metadata()),
            (self.microphone_sensor(), other.microphone_sensor()),
            (self.barometer_sensor(), other.barometer_sensor()),
            (self.location_sensor(), other.location_sensor()),
            (self.time_synchronization_sensor(), other.time_synchronization_sensor()),
            (self.accelerometer_sensor(), other.accelerometer_sensor()),
            (self.magnetometer_sensor(), other.magnetometer_sensor()),
            (self.gyroscope_sensor(), other.gyroscope_sensor()),
            (self.light_sensor(), other.light_sensor()),
            (self.infrared_sensor(), other.infrared_sensor())
        ])
        # Filter only out only the differences
        diffs = filter(lambda tuple2: tuple2[0], diffs)
        # Extract the difference string
        diffs = map(lambda tuple2: tuple2[1], diffs)
        return list(diffs)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket">WrappedRedvoxPacket</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, redvox_packet=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initializes this wrapped redvox packet.
:param redvox_packet: A protobuf redvox packet.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.__init__', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.__init__" class="source">
    <pre><code>def __init__(self, redvox_packet: api900_pb2.RedvoxPacket = None):
    """
    Initializes this wrapped redvox packet.
    :param redvox_packet: A protobuf redvox packet.
    """
    if redvox_packet is None:
        self._redvox_packet = api900_pb2.RedvoxPacket()
        self._evenly_sampled_channels_field = list()
        self._unevenly_sampled_channels_field = list()
        self._metadata_list = list()
        self._channel_cache = {}
    else:
        self._redvox_packet: api900_pb2.RedvoxPacket = redvox_packet
        """Protobuf api 900 redvox packet"""
        self._evenly_sampled_channels_field: typing.List[EvenlySampledChannel] = list(
            map(EvenlySampledChannel, reader_utils.repeated_to_array(redvox_packet.evenly_sampled_channels)))
        """List of evenly sampled channels"""
        self._unevenly_sampled_channels_field: typing.List[UnevenlySampledChannel] = list(
            map(UnevenlySampledChannel,
                reader_utils.repeated_to_array(redvox_packet.unevenly_sampled_channels)))
        """List of unevenly sampled channels"""
        self._metadata_list: typing.List[str] = reader_utils.repeated_to_list(redvox_packet.metadata)
        """List of metadata"""
        self._channel_cache: typing.Dict[int, typing.Union[EvenlySampledChannel, UnevenlySampledChannel]] = {}
        """Holds a mapping of channel type to channel for O(1) access."""
        # Initialize channel cache
        for evenly_sampled_channel in self._evenly_sampled_channels_field:
            for channel_type in evenly_sampled_channel.channel_types:
                self._channel_cache[channel_type] = evenly_sampled_channel
        for unevenly_sampled_channel in self._unevenly_sampled_channels_field:
            for channel_type in unevenly_sampled_channel.channel_types:
                self._channel_cache[channel_type] = unevenly_sampled_channel
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.accelerometer_channel">
    <p>def <span class="ident">accelerometer_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>accelerometer_channel has been deprecated in version 2.0.0. Use accelerometer_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.accelerometer_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.accelerometer_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", accelerometer_sensor)
def accelerometer_channel(self) -> typing.Optional[_accelerometer_sensor.AccelerometerSensor]:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.accelerometer_sensor">
    <p>def <span class="ident">accelerometer_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the high-level accelerometer channel API or None if this packet doesn't contain a channel of this type.
:return: the high-level accelerometer channel API or None if this packet doesn't contain a channel of this type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.accelerometer_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.accelerometer_sensor" class="source">
    <pre><code>def accelerometer_sensor(self) -> typing.Optional[_accelerometer_sensor.AccelerometerSensor]:
    """
    Returns the high-level accelerometer channel API or None if this packet doesn't contain a channel of this type.
    :return: the high-level accelerometer channel API or None if this packet doesn't contain a channel of this type.
    """
    if self.has_accelerometer_sensor():
        return _accelerometer_sensor.AccelerometerSensor(self._get_channel(api900_pb2.ACCELEROMETER_X))
    return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.acquisition_server">
    <p>def <span class="ident">acquisition_server</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.acquisition_server', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.acquisition_server" class="source">
    <pre><code>def acquisition_server(self) -> str:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.acquisition_server
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.add_metadata">
    <p>def <span class="ident">add_metadata</span>(</p><p>self, key, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Adds a key pair value to the metadata.
:param key: The key.
:param value: The value.
:return: This instance of a WrappedRedvoxPacket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.add_metadata', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.add_metadata" class="source">
    <pre><code>def add_metadata(self, key: str, value: str) -> 'WrappedRedvoxPacket':
    """
    Adds a key pair value to the metadata.
    :param key: The key.
    :param value: The value.
    :return: This instance of a WrappedRedvoxPacket.
    """
    metadata = self.metadata_as_dict()
    metadata[key] = value if isinstance(value, str) else str(value)
    self.set_metadata_as_dict(metadata)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.api">
    <p>def <span class="ident">api</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.api', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.api" class="source">
    <pre><code>def api(self) -> int:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.api
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_file_start_timestamp_epoch_microseconds_utc">
    <p>def <span class="ident">app_file_start_timestamp_epoch_microseconds_utc</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_file_start_timestamp_epoch_microseconds_utc', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_file_start_timestamp_epoch_microseconds_utc" class="source">
    <pre><code>def app_file_start_timestamp_epoch_microseconds_utc(self) -> int:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.app_file_start_timestamp_epoch_microseconds_utc
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_file_start_timestamp_machine">
    <p>def <span class="ident">app_file_start_timestamp_machine</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_file_start_timestamp_machine', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_file_start_timestamp_machine" class="source">
    <pre><code>def app_file_start_timestamp_machine(self) -> int:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.app_file_start_timestamp_machine
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_version">
    <p>def <span class="ident">app_version</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_version', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.app_version" class="source">
    <pre><code>def app_version(self) -> str:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.app_version
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authenticated_email">
    <p>def <span class="ident">authenticated_email</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authenticated_email', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authenticated_email" class="source">
    <pre><code>def authenticated_email(self) -> str:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.authenticated_email
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authentication_server">
    <p>def <span class="ident">authentication_server</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authentication_server', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authentication_server" class="source">
    <pre><code>def authentication_server(self) -> str:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.authentication_server
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authentication_token">
    <p>def <span class="ident">authentication_token</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authentication_token', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.authentication_token" class="source">
    <pre><code>def authentication_token(self) -> str:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.authentication_token
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.barometer_channel">
    <p>def <span class="ident">barometer_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>barometer_channel has been deprecated in version 2.0.0. Use barometer_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.barometer_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.barometer_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", barometer_sensor)
def barometer_channel(self) -> typing.Optional[_barometer_sensor.BarometerSensor]:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.barometer_sensor">
    <p>def <span class="ident">barometer_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the high-level barometer channel API or None if this packet doesn't contain a channel of this type.
:return: the high-level barometer channel API or None if this packet doesn't contain a channel of this type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.barometer_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.barometer_sensor" class="source">
    <pre><code>def barometer_sensor(self) -> typing.Optional[_barometer_sensor.BarometerSensor]:
    """
    Returns the high-level barometer channel API or None if this packet doesn't contain a channel of this type.
    :return: the high-level barometer channel API or None if this packet doesn't contain a channel of this type.
    """
    if self.has_barometer_sensor():
        return _barometer_sensor.BarometerSensor(self._get_channel(api900_pb2.BAROMETER))
    return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.battery_level_percent">
    <p>def <span class="ident">battery_level_percent</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.battery_level_percent', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.battery_level_percent" class="source">
    <pre><code>def battery_level_percent(self) -> float:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.battery_level_percent
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.best_latency">
    <p>def <span class="ident">best_latency</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the best latency from the metadata if it exists.
:return: The best latency from the metadata if it exists.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.best_latency', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.best_latency" class="source">
    <pre><code>def best_latency(self) -> typing.Optional[float]:
    """
    Returns the best latency from the metadata if it exists.
    :return: The best latency from the metadata if it exists.
    """
    try:
        return float(self.metadata_as_dict()["bestLatency"])
    except (KeyError, ValueError):
        return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.best_offset">
    <p>def <span class="ident">best_offset</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the best offset from the metadata if it exists.
:return: The best offset from the metadata if it exists.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.best_offset', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.best_offset" class="source">
    <pre><code>def best_offset(self) -> typing.Optional[float]:
    """
    Returns the best offset from the metadata if it exists.
    :return: The best offset from the metadata if it exists.
    """
    try:
        return float(self.metadata_as_dict()["bestOffset"])
    except (KeyError, ValueError):
        return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.clone">
    <p>def <span class="ident">clone</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a clone of this WrappedRedvoxPacket.
:return: A clone of this WrappedRedvoxPacket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.clone', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.clone" class="source">
    <pre><code>def clone(self) -> 'WrappedRedvoxPacket':
    """
    Returns a clone of this WrappedRedvoxPacket.
    :return: A clone of this WrappedRedvoxPacket.
    """
    return redvox.api900.reader.read_rdvxz_buffer(self.compressed_buffer())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.compressed_buffer">
    <p>def <span class="ident">compressed_buffer</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the compressed buffer associated with this packet.
:return: The compressed buffer associated with this packet.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.compressed_buffer', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.compressed_buffer" class="source">
    <pre><code>def compressed_buffer(self) -> bytes:
    """
    Returns the compressed buffer associated with this packet.
    :return: The compressed buffer associated with this packet.
    """
    return reader_utils.lz4_compress(self._redvox_packet.SerializeToString())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.concat">
    <p>def <span class="ident">concat</span>(</p><p>self, wrapped_redvox_packets)</p>
    </div>
    

    
  
    <div class="desc"><p>Concatenates this packet with other packets.
:param wrapped_redvox_packets: Other packets to concatenate with this packet.
:return: A list of packets each containing a continuous set of data.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.concat', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.concat" class="source">
    <pre><code>def concat(self, wrapped_redvox_packets: typing.List['WrappedRedvoxPacket']) -> typing.List['WrappedRedvoxPacket']:
    """
    Concatenates this packet with other packets.
    :param wrapped_redvox_packets: Other packets to concatenate with this packet.
    :return: A list of packets each containing a continuous set of data.
    """
    return redvox.api900.concat.concat_wrapped_redvox_packets([self] + wrapped_redvox_packets)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.default_filename">
    <p>def <span class="ident">default_filename</span>(</p><p>self, extension=&#39;rdvxz&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Constructs a default filename from the packet's metadata.
:param extension: An optional extension to use.
:return: A default filename from the packet's metadata.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.default_filename', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.default_filename" class="source">
    <pre><code>def default_filename(self, extension: str = "rdvxz") -> str:
    """
    Constructs a default filename from the packet's metadata.
    :param extension: An optional extension to use.
    :return: A default filename from the packet's metadata.
    """
    return "%s_%d.%s" % (self.redvox_id(), int(round(self.app_file_start_timestamp_machine() / 1000.0)), extension)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_make">
    <p>def <span class="ident">device_make</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_make', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_make" class="source">
    <pre><code>def device_make(self) -> str:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.device_make
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_model">
    <p>def <span class="ident">device_model</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_model', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_model" class="source">
    <pre><code>def device_model(self) -> str:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.device_model
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_os">
    <p>def <span class="ident">device_os</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_os', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_os" class="source">
    <pre><code>def device_os(self) -> str:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.device_os
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_os_version">
    <p>def <span class="ident">device_os_version</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_os_version', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_os_version" class="source">
    <pre><code>def device_os_version(self) -> str:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.device_os_version
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_temperature_c">
    <p>def <span class="ident">device_temperature_c</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_temperature_c', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.device_temperature_c" class="source">
    <pre><code>def device_temperature_c(self) -> float:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.device_temperature_c
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.diff">
    <p>def <span class="ident">diff</span>(</p><p>self, other)</p>
    </div>
    

    
  
    <div class="desc"><p>Finds the differences (if any) between two WrappedRedvoxPackets.
:param other: The other wrapped redvox packet to compare to.
:return: A list of differences or an empty list if there are none.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.diff', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.diff" class="source">
    <pre><code>def diff(self, other: 'WrappedRedvoxPacket') -> typing.List[str]:
    """
    Finds the differences (if any) between two WrappedRedvoxPackets.
    :param other: The other wrapped redvox packet to compare to.
    :return: A list of differences or an empty list if there are none.
    """
    diffs = map(lambda tuple2: reader_utils.diff(tuple2[0], tuple2[1]), [
        (self.api(), other.api()),
        (self.redvox_id(), other.redvox_id()),
        (self.uuid(), other.uuid()),
        (self.authenticated_email(), other.authenticated_email()),
        (self.authentication_token(), other.authentication_token()),
        (self.firebase_token(), other.firebase_token()),
        (self.is_backfilled(), other.is_backfilled()),
        (self.is_private(), other.is_private()),
        (self.is_scrambled(), other.is_scrambled()),
        (self.device_make(), other.device_make()),
        (self.device_model(), other.device_model()),
        (self.device_os(), other.device_os()),
        (self.device_os_version(), other.device_os_version()),
        (self.app_version(), other.app_version()),
        (self.battery_level_percent(), other.battery_level_percent()),
        (self.device_temperature_c(), other.device_temperature_c()),
        (self.acquisition_server(), other.acquisition_server()),
        (self.time_synchronization_server(), other.time_synchronization_server()),
        (self.authentication_server(), other.authentication_server()),
        (self.app_file_start_timestamp_epoch_microseconds_utc(),
         other.app_file_start_timestamp_epoch_microseconds_utc()),
        (self.app_file_start_timestamp_machine(), other.app_file_start_timestamp_machine()),
        (self.server_timestamp_epoch_microseconds_utc(),
         other.server_timestamp_epoch_microseconds_utc()),
        (self.metadata(), other.metadata()),
        (self.microphone_sensor(), other.microphone_sensor()),
        (self.barometer_sensor(), other.barometer_sensor()),
        (self.location_sensor(), other.location_sensor()),
        (self.time_synchronization_sensor(), other.time_synchronization_sensor()),
        (self.accelerometer_sensor(), other.accelerometer_sensor()),
        (self.magnetometer_sensor(), other.magnetometer_sensor()),
        (self.gyroscope_sensor(), other.gyroscope_sensor()),
        (self.light_sensor(), other.light_sensor()),
        (self.infrared_sensor(), other.infrared_sensor())
    ])
    # Filter only out only the differences
    diffs = filter(lambda tuple2: tuple2[0], diffs)
    # Extract the difference string
    diffs = map(lambda tuple2: tuple2[1], diffs)
    return list(diffs)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.duration_s">
    <p>def <span class="ident">duration_s</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>The duration of this WrappedRedvoxPacket in seconds.
:return: The duration of this WrappedRedvoxPacket in seconds.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.duration_s', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.duration_s" class="source">
    <pre><code>def duration_s(self) -> float:
    """
    The duration of this WrappedRedvoxPacket in seconds.
    :return: The duration of this WrappedRedvoxPacket in seconds.
    """
    microphone_sensor = self.microphone_sensor()
    return len(microphone_sensor.payload_values()) / microphone_sensor.sample_rate_hz()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.end_timestamp_us_utc">
    <p>def <span class="ident">end_timestamp_us_utc</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the end timestamp of a WrappedRedvoxPacket.
:return: The end timestamp of a WrappedRedvoxPacket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.end_timestamp_us_utc', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.end_timestamp_us_utc" class="source">
    <pre><code>def end_timestamp_us_utc(self):
    """
    Returns the end timestamp of a WrappedRedvoxPacket.
    :return: The end timestamp of a WrappedRedvoxPacket.
    """
    return self.start_timestamp_us_utc() + date_time_utils.seconds_to_microseconds(self.duration_s())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.firebase_token">
    <p>def <span class="ident">firebase_token</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.firebase_token', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.firebase_token" class="source">
    <pre><code>def firebase_token(self) -> str:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.firebase_token
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.gyroscope_channel">
    <p>def <span class="ident">gyroscope_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>gyroscope_channel has been deprecated in version 2.0.0. Use gyroscope_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.gyroscope_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.gyroscope_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", gyroscope_sensor)
def gyroscope_channel(self) -> typing.Optional[_gyroscope_sensor.GyroscopeSensor]:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.gyroscope_sensor">
    <p>def <span class="ident">gyroscope_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the high-level gyroscope channel API or None if this packet doesn't contain a channel of this type.
:return: the high-level gyroscope channel API or None if this packet doesn't contain a channel of this type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.gyroscope_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.gyroscope_sensor" class="source">
    <pre><code>def gyroscope_sensor(self) -> typing.Optional[_gyroscope_sensor.GyroscopeSensor]:
    """
    Returns the high-level gyroscope channel API or None if this packet doesn't contain a channel of this type.
    :return: the high-level gyroscope channel API or None if this packet doesn't contain a channel of this type.
    """
    if self.has_gyroscope_sensor():
        return _gyroscope_sensor.GyroscopeSensor(self._get_channel(api900_pb2.GYROSCOPE_X))
    return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_accelerometer_channel">
    <p>def <span class="ident">has_accelerometer_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>has_accelerometer_channel has been deprecated in version 2.0.0. Use has_accelerometer_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_accelerometer_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_accelerometer_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", has_accelerometer_sensor)
def has_accelerometer_channel(self) -> bool:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_accelerometer_sensor">
    <p>def <span class="ident">has_accelerometer_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns if this packet has an accelerometer channel.
:return: If this packet has an accelerometer channel.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_accelerometer_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_accelerometer_sensor" class="source">
    <pre><code>def has_accelerometer_sensor(self) -> bool:
    """
    Returns if this packet has an accelerometer channel.
    :return: If this packet has an accelerometer channel.
    """
    return self._has_channels([api900_pb2.ACCELEROMETER_X, api900_pb2.ACCELEROMETER_Y, api900_pb2.ACCELEROMETER_Z])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_barometer_channel">
    <p>def <span class="ident">has_barometer_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>has_barometer_channel has been deprecated in version 2.0.0. Use has_barometer_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_barometer_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_barometer_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", has_barometer_sensor)
def has_barometer_channel(self) -> bool:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_barometer_sensor">
    <p>def <span class="ident">has_barometer_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns if this packet has a barometer channel.
:return: If this packet has a barometer channel.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_barometer_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_barometer_sensor" class="source">
    <pre><code>def has_barometer_sensor(self) -> bool:
    """
    Returns if this packet has a barometer channel.
    :return: If this packet has a barometer channel.
    """
    return self._has_channel(api900_pb2.BAROMETER)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_gyroscope_channel">
    <p>def <span class="ident">has_gyroscope_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>has_gyroscope_channel has been deprecated in version 2.0.0. Use has_gyroscope_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_gyroscope_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_gyroscope_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", has_gyroscope_sensor)
def has_gyroscope_channel(self) -> bool:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_gyroscope_sensor">
    <p>def <span class="ident">has_gyroscope_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns if this packet has a gyroscope channel.
:return: If this packet has a gyroscope channel.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_gyroscope_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_gyroscope_sensor" class="source">
    <pre><code>def has_gyroscope_sensor(self) -> bool:
    """
    Returns if this packet has a gyroscope channel.
    :return: If this packet has a gyroscope channel.
    """
    return self._has_channels([api900_pb2.GYROSCOPE_X, api900_pb2.GYROSCOPE_Y, api900_pb2.GYROSCOPE_Z])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_image_channel">
    <p>def <span class="ident">has_image_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>has_image_channel has been deprecated in version 2.0.0. Use has_image_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_image_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_image_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", has_image_sensor)
def has_image_channel(self) -> bool:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_image_sensor">
    <p>def <span class="ident">has_image_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns if this packet has an image channel.
:return: If this packlet has an image channel.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_image_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_image_sensor" class="source">
    <pre><code>def has_image_sensor(self) -> bool:
    """
    Returns if this packet has an image channel.
    :return: If this packlet has an image channel.
    """
    return self._has_channel(api900_pb2.IMAGE)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_infrared_channel">
    <p>def <span class="ident">has_infrared_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>has_infrared_channel has been deprecated in version 2.0.0. Use has_infrared_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_infrared_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_infrared_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", has_infrared_sensor)
def has_infrared_channel(self) -> bool:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_infrared_sensor">
    <p>def <span class="ident">has_infrared_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns if this packet has an infrared channel.
:return: If this packlet has an infrared channel.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_infrared_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_infrared_sensor" class="source">
    <pre><code>def has_infrared_sensor(self) -> bool:
    """
    Returns if this packet has an infrared channel.
    :return: If this packlet has an infrared channel.
    """
    return self._has_channel(api900_pb2.INFRARED)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_light_channel">
    <p>def <span class="ident">has_light_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>has_light_channel has been deprecated in version 2.0.0. Use has_light_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_light_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_light_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", has_light_sensor)
def has_light_channel(self) -> bool:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_light_sensor">
    <p>def <span class="ident">has_light_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns if this packet has a light channel.
:return: If this packet has a light channel.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_light_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_light_sensor" class="source">
    <pre><code>def has_light_sensor(self) -> bool:
    """
    Returns if this packet has a light channel.
    :return: If this packet has a light channel.
    """
    return self._has_channel(api900_pb2.LIGHT)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_location_channel">
    <p>def <span class="ident">has_location_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>has_location_channel has been deprecated in version 2.0.0. Use has_location_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_location_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_location_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", has_location_sensor)
def has_location_channel(self) -> bool:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_location_sensor">
    <p>def <span class="ident">has_location_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns if this packet has a location channel.
:return: If this packet has a location channel.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_location_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_location_sensor" class="source">
    <pre><code>def has_location_sensor(self) -> bool:
    """
    Returns if this packet has a location channel.
    :return: If this packet has a location channel.
    """
    return (self._has_channels(
        [api900_pb2.LATITUDE, api900_pb2.LONGITUDE, api900_pb2.ALTITUDE, api900_pb2.SPEED,
         api900_pb2.ACCURACY]) or self._has_channels([api900_pb2.LATITUDE, api900_pb2.LONGITUDE]))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_magnetometer_channel">
    <p>def <span class="ident">has_magnetometer_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>has_magnetometer_channel has been deprecated in version 2.0.0. Use has_magnetometer_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_magnetometer_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_magnetometer_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", has_magnetometer_sensor)
def has_magnetometer_channel(self) -> bool:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_magnetometer_sensor">
    <p>def <span class="ident">has_magnetometer_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns if this packet has a magnetometer channel.
:return: If this packet has a magnetometer channel.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_magnetometer_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_magnetometer_sensor" class="source">
    <pre><code>def has_magnetometer_sensor(self) -> bool:
    """
    Returns if this packet has a magnetometer channel.
    :return: If this packet has a magnetometer channel.
    """
    return self._has_channels([api900_pb2.MAGNETOMETER_X, api900_pb2.MAGNETOMETER_Y, api900_pb2.MAGNETOMETER_Z])
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_microphone_channel">
    <p>def <span class="ident">has_microphone_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>has_microphone_channel has been deprecated in version 2.0.0. Use has_microphone_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_microphone_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_microphone_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", has_microphone_sensor)
def has_microphone_channel(self) -> bool:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_microphone_sensor">
    <p>def <span class="ident">has_microphone_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns if this packet has a microphone channel.
:return: If this packet has a microphone channel.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_microphone_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_microphone_sensor" class="source">
    <pre><code>def has_microphone_sensor(self) -> bool:
    """
    Returns if this packet has a microphone channel.
    :return: If this packet has a microphone channel.
    """
    return self._has_channel(api900_pb2.MICROPHONE)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_time_synchronization_channel">
    <p>def <span class="ident">has_time_synchronization_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>has_time_synchronization_channel has been deprecated in version 2.0.0. Use has_time_synchronization_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_time_synchronization_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_time_synchronization_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", has_time_synchronization_sensor)
def has_time_synchronization_channel(self) -> bool:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_time_synchronization_sensor">
    <p>def <span class="ident">has_time_synchronization_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns if this packet has a time synchronization channel.
:return: If this packet has a time synchronization channel.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_time_synchronization_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.has_time_synchronization_sensor" class="source">
    <pre><code>def has_time_synchronization_sensor(self) -> bool:
    """
    Returns if this packet has a time synchronization channel.
    :return: If this packet has a time synchronization channel.
    """
    if self._has_channel(api900_pb2.TIME_SYNCHRONIZATION):
        ch = _time_synchronization_sensor.TimeSynchronizationSensor(
            self._get_channel(api900_pb2.TIME_SYNCHRONIZATION))
        return len(ch.payload_values()) > 0
    return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.image_channel">
    <p>def <span class="ident">image_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>image_channel has been deprecated in version 2.0.0. Use image_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.image_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.image_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", image_sensor)
def image_channel(self) -> typing.Optional[_image_sensor.ImageSensor]:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.image_sensor">
    <p>def <span class="ident">image_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the high-level image channel API or None if this packet doesn't contain a channel of this type.
:return: the high-level image channel API or None if this packet doesn't contain a channel of this type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.image_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.image_sensor" class="source">
    <pre><code>def image_sensor(self) -> typing.Optional[_image_sensor.ImageSensor]:
    """
    Returns the high-level image channel API or None if this packet doesn't contain a channel of this type.
    :return: the high-level image channel API or None if this packet doesn't contain a channel of this type.
    """
    if self.has_image_sensor():
        return _image_sensor.ImageSensor(self._get_channel(api900_pb2.IMAGE))
    return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.infrared_channel">
    <p>def <span class="ident">infrared_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>infrared_channel has been deprecated in version 2.0.0. Use infrared_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.infrared_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.infrared_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", infrared_sensor)
def infrared_channel(self) -> typing.Optional[_infrared_sensor.InfraredSensor]:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.infrared_sensor">
    <p>def <span class="ident">infrared_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the high-level infrared channel API or None if this packet doesn't contain a channel of this type.
:return: the high-level infrared channel API or None if this packet doesn't contain a channel of this type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.infrared_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.infrared_sensor" class="source">
    <pre><code>def infrared_sensor(self) -> typing.Optional[_infrared_sensor.InfraredSensor]:
    """
    Returns the high-level infrared channel API or None if this packet doesn't contain a channel of this type.
    :return: the high-level infrared channel API or None if this packet doesn't contain a channel of this type.
    """
    if self.has_infrared_sensor():
        return _infrared_sensor.InfraredSensor(self._get_channel(api900_pb2.INFRARED))
    return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_backfilled">
    <p>def <span class="ident">is_backfilled</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_backfilled', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_backfilled" class="source">
    <pre><code>def is_backfilled(self) -> bool:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.is_backfilled
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_private">
    <p>def <span class="ident">is_private</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_private', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_private" class="source">
    <pre><code>def is_private(self) -> bool:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.is_private
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_scrambled">
    <p>def <span class="ident">is_scrambled</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_scrambled', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_scrambled" class="source">
    <pre><code>def is_scrambled(self) -> bool:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.is_scrambled
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_synch_corrected">
    <p>def <span class="ident">is_synch_corrected</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the isSynchCorrected value from the metadata if it exists.
:return: The isSynchCorrected value from the metadata if it exists.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_synch_corrected', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.is_synch_corrected" class="source">
    <pre><code>def is_synch_corrected(self) -> bool:
    """
    Returns the isSynchCorrected value from the metadata if it exists.
    :return: The isSynchCorrected value from the metadata if it exists.
    """
    def _parse_bool(s: str) -> bool:
        return s == "true" or s == "True"
    try:
        return _parse_bool(self.metadata_as_dict()["isSynchCorrected"])
    except (KeyError, ValueError):
        return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.light_channel">
    <p>def <span class="ident">light_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>light_channel has been deprecated in version 2.0.0. Use light_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.light_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.light_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", light_sensor)
def light_channel(self) -> typing.Optional[_light_sensor.LightSensor]:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.light_sensor">
    <p>def <span class="ident">light_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the high-level light channel API or None if this packet doesn't contain a channel of this type.
:return: the high-level light channel API or None if this packet doesn't contain a channel of this type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.light_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.light_sensor" class="source">
    <pre><code>def light_sensor(self) -> typing.Optional[_light_sensor.LightSensor]:
    """
    Returns the high-level light channel API or None if this packet doesn't contain a channel of this type.
    :return: the high-level light channel API or None if this packet doesn't contain a channel of this type.
    """
    if self.has_light_sensor():
        return _light_sensor.LightSensor(self._get_channel(api900_pb2.LIGHT))
    return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.location_channel">
    <p>def <span class="ident">location_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>location_channel has been deprecated in version 2.0.0. Use location_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.location_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.location_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", location_sensor)
def location_channel(self) -> typing.Optional[_location_sensor.LocationSensor]:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.location_sensor">
    <p>def <span class="ident">location_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the high-level location channel API or None if this packet doesn't contain a channel of this type.
:return: the high-level location channel API or None if this packet doesn't contain a channel of this type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.location_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.location_sensor" class="source">
    <pre><code>def location_sensor(self) -> typing.Optional[_location_sensor.LocationSensor]:
    """
    Returns the high-level location channel API or None if this packet doesn't contain a channel of this type.
    :return: the high-level location channel API or None if this packet doesn't contain a channel of this type.
    """
    if self.has_location_sensor():
        return _location_sensor.LocationSensor(self._get_channel(api900_pb2.LATITUDE))
    return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.mach_time_zero">
    <p>def <span class="ident">mach_time_zero</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the mach time zero from the metadata if it exists.
:return: The mach time zero from the metadata if it exists.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.mach_time_zero', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.mach_time_zero" class="source">
    <pre><code>def mach_time_zero(self) -> typing.Optional[int]:
    """
    Returns the mach time zero from the metadata if it exists.
    :return: The mach time zero from the metadata if it exists.
    """
    try:
        return int(self.metadata_as_dict()["machTimeZero"])
    except (KeyError, ValueError):
        return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.magnetometer_channel">
    <p>def <span class="ident">magnetometer_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>magnetometer_channel has been deprecated in version 2.0.0. Use magnetometer_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.magnetometer_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.magnetometer_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", magnetometer_sensor)
def magnetometer_channel(self) -> typing.Optional[_magnetometer_sensor.MagnetometerSensor]:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.magnetometer_sensor">
    <p>def <span class="ident">magnetometer_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the high-level magnetometer channel API or None if this packet doesn't contain a channel of this type.
:return: the high-level magnetometer channel API or None if this packet doesn't contain a channel of this type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.magnetometer_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.magnetometer_sensor" class="source">
    <pre><code>def magnetometer_sensor(self) -> typing.Optional[_magnetometer_sensor.MagnetometerSensor]:
    """
    Returns the high-level magnetometer channel API or None if this packet doesn't contain a channel of this type.
    :return: the high-level magnetometer channel API or None if this packet doesn't contain a channel of this type.
    """
    if self.has_magnetometer_sensor():
        return _magnetometer_sensor.MagnetometerSensor(self._get_channel(api900_pb2.MAGNETOMETER_X))
    return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.metadata">
    <p>def <span class="ident">metadata</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.metadata', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.metadata" class="source">
    <pre><code>def metadata(self) -> typing.List[str]:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._metadata_list
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.metadata_as_dict">
    <p>def <span class="ident">metadata_as_dict</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return this packet's metadata as a key-value Python dictionary.
:return: This packet's metadata as a key-value Python dictionary.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.metadata_as_dict', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.metadata_as_dict" class="source">
    <pre><code>def metadata_as_dict(self) -> typing.Dict[str, str]:
    """
    Return this packet's metadata as a key-value Python dictionary.
    :return: This packet's metadata as a key-value Python dictionary.
    """
    return reader_utils.get_metadata_as_dict(self._metadata_list)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.microphone_channel">
    <p>def <span class="ident">microphone_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>microphone_channel has been deprecated in version 2.0.0. Use microphone_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.microphone_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.microphone_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", microphone_sensor)
def microphone_channel(self) -> typing.Optional[_microphone_sensor.MicrophoneSensor]:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.microphone_sensor">
    <p>def <span class="ident">microphone_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the high-level microphone channel API or None if this packet doesn't contain a channel of this type.
:return: the high-level microphone channel API or None if this packet doesn't contain a channel of this type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.microphone_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.microphone_sensor" class="source">
    <pre><code>def microphone_sensor(self) -> typing.Optional[_microphone_sensor.MicrophoneSensor]:
    """
    Returns the high-level microphone channel API or None if this packet doesn't contain a channel of this type.
    :return: the high-level microphone channel API or None if this packet doesn't contain a channel of this type.
    """
    if self.has_microphone_sensor():
        return _microphone_sensor.MicrophoneSensor(self._get_channel(api900_pb2.MICROPHONE))
    return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.redvox_id">
    <p>def <span class="ident">redvox_id</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.redvox_id', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.redvox_id" class="source">
    <pre><code>def redvox_id(self) -> str:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.redvox_id
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.redvox_packet">
    <p>def <span class="ident">redvox_packet</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>returns the protobuf redvox packet
:return: protobuf redvox packet</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.redvox_packet', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.redvox_packet" class="source">
    <pre><code>def redvox_packet(self) -> api900_pb2.RedvoxPacket:
    """
    returns the protobuf redvox packet
    :return: protobuf redvox packet
    """
    return self._redvox_packet
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.server_timestamp_epoch_microseconds_utc">
    <p>def <span class="ident">server_timestamp_epoch_microseconds_utc</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.server_timestamp_epoch_microseconds_utc', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.server_timestamp_epoch_microseconds_utc" class="source">
    <pre><code>def server_timestamp_epoch_microseconds_utc(self) -> int:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.server_timestamp_epoch_microseconds_utc
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_accelerometer_channel">
    <p>def <span class="ident">set_accelerometer_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>set_accelerometer_channel has been deprecated in version 2.0.0. Use set_accelerometer_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_accelerometer_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_accelerometer_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", set_accelerometer_sensor)
def set_accelerometer_channel(self,
                              accelerometer_sensor: typing.Optional[
                                  _accelerometer_sensor.AccelerometerSensor]) -> 'WrappedRedvoxPacket':
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_accelerometer_sensor">
    <p>def <span class="ident">set_accelerometer_sensor</span>(</p><p>self, accelerometer_sensor)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets this packet's accelerometer sensor. A channel can be removed by passing in None.
:param accelerometer_sensor: An optional instance of a accelerometer sensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_accelerometer_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_accelerometer_sensor" class="source">
    <pre><code>def set_accelerometer_sensor(self,
                             accelerometer_sensor: typing.Optional[
                                 _accelerometer_sensor.AccelerometerSensor]) -> 'WrappedRedvoxPacket':
    """
    Sets this packet's accelerometer sensor. A channel can be removed by passing in None.
    :param accelerometer_sensor: An optional instance of a accelerometer sensor.
    """
    if self.has_accelerometer_sensor():
        self._delete_channel(api900_pb2.ACCELEROMETER_X)
    if accelerometer_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(accelerometer_sensor._unevenly_sampled_channel)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_acquisition_server">
    <p>def <span class="ident">set_acquisition_server</span>(</p><p>self, server)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the acquisition server url
:param server: url to acquisition server</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_acquisition_server', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_acquisition_server" class="source">
    <pre><code>def set_acquisition_server(self, server: str) -> 'WrappedRedvoxPacket':
    """
    sets the acquisition server url
    :param server: url to acquisition server
    """
    self._redvox_packet.acquisition_server = server
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_api">
    <p>def <span class="ident">set_api</span>(</p><p>self, version)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the api version number
:param version: version number</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_api', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_api" class="source">
    <pre><code>def set_api(self, version: int) -> 'WrappedRedvoxPacket':
    """
    sets the api version number
    :param version: version number
    """
    self._redvox_packet.api = version
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_file_start_timestamp_epoch_microseconds_utc">
    <p>def <span class="ident">set_app_file_start_timestamp_epoch_microseconds_utc</span>(</p><p>self, time)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the timestamp of packet creation
:param time: time when packet was created in microseconds since utc epoch</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_file_start_timestamp_epoch_microseconds_utc', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_file_start_timestamp_epoch_microseconds_utc" class="source">
    <pre><code>def set_app_file_start_timestamp_epoch_microseconds_utc(self, time: int) -> 'WrappedRedvoxPacket':
    """
    sets the timestamp of packet creation
    :param time: time when packet was created in microseconds since utc epoch
    """
    self._redvox_packet.app_file_start_timestamp_epoch_microseconds_utc = time
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_file_start_timestamp_machine">
    <p>def <span class="ident">set_app_file_start_timestamp_machine</span>(</p><p>self, time)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the internal machine timestamp of packet creation
:param time: time when packet was created on local machine</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_file_start_timestamp_machine', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_file_start_timestamp_machine" class="source">
    <pre><code>def set_app_file_start_timestamp_machine(self, time: int) -> 'WrappedRedvoxPacket':
    """
    sets the internal machine timestamp of packet creation
    :param time: time when packet was created on local machine
    """
    self._redvox_packet.app_file_start_timestamp_machine = time
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_version">
    <p>def <span class="ident">set_app_version</span>(</p><p>self, version)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the app version number
:param version: app version string</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_version', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_app_version" class="source">
    <pre><code>def set_app_version(self, version: str) -> 'WrappedRedvoxPacket':
    """
    sets the app version number
    :param version: app version string
    """
    self._redvox_packet.app_version = version
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authenticated_email">
    <p>def <span class="ident">set_authenticated_email</span>(</p><p>self, email)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the authenticated email
:param email: authenticated email string</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authenticated_email', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authenticated_email" class="source">
    <pre><code>def set_authenticated_email(self, email: str) -> 'WrappedRedvoxPacket':
    """
    sets the authenticated email
    :param email: authenticated email string
    """
    self._redvox_packet.authenticated_email = email
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authentication_server">
    <p>def <span class="ident">set_authentication_server</span>(</p><p>self, server)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the authentication server url
:param server: url to authentication server</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authentication_server', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authentication_server" class="source">
    <pre><code>def set_authentication_server(self, server: str) -> 'WrappedRedvoxPacket':
    """
    sets the authentication server url
    :param server: url to authentication server
    """
    self._redvox_packet.authentication_server = server
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authentication_token">
    <p>def <span class="ident">set_authentication_token</span>(</p><p>self, token)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the authentication token
:param token: authentication token string</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authentication_token', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_authentication_token" class="source">
    <pre><code>def set_authentication_token(self, token: str) -> 'WrappedRedvoxPacket':
    """
    sets the authentication token
    :param token: authentication token string
    """
    self._redvox_packet.authentication_token = token
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_barometer_channel">
    <p>def <span class="ident">set_barometer_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>set_barometer_channel has been deprecated in version 2.0.0. Use set_barometer_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_barometer_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_barometer_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", set_barometer_sensor)
def set_barometer_channel(self, barometer_sensor: typing.Optional[
        _barometer_sensor.BarometerSensor]) -> 'WrappedRedvoxPacket':
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_barometer_sensor">
    <p>def <span class="ident">set_barometer_sensor</span>(</p><p>self, barometer_sensor)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets this packets barometer sensor. A channel can be removed by passing in None.
:param barometer_sensor: An optional instance of a barometer sensor.
:return: This instance of a wrapped redvox packet.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_barometer_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_barometer_sensor" class="source">
    <pre><code>def set_barometer_sensor(self, barometer_sensor: typing.Optional[
        _barometer_sensor.BarometerSensor]) -> 'WrappedRedvoxPacket':
    """
    Sets this packets barometer sensor. A channel can be removed by passing in None.
    :param barometer_sensor: An optional instance of a barometer sensor.
    :return: This instance of a wrapped redvox packet.
    """
    if self.has_barometer_sensor():
        self._delete_channel(api900_pb2.BAROMETER)
    if barometer_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(barometer_sensor._unevenly_sampled_channel)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_battery_level_percent">
    <p>def <span class="ident">set_battery_level_percent</span>(</p><p>self, percent)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the percentage of battery left
:param percent: percentage of battery left</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_battery_level_percent', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_battery_level_percent" class="source">
    <pre><code>def set_battery_level_percent(self, percent: float) -> 'WrappedRedvoxPacket':
    """
    sets the percentage of battery left
    :param percent: percentage of battery left
    """
    self._redvox_packet.battery_level_percent = percent
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_best_latency">
    <p>def <span class="ident">set_best_latency</span>(</p><p>self, best_latency)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets the best latency in the packet's metadata.
:param best_latency: The best latency to use.
:return: An instance of this wrapped packet.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_best_latency', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_best_latency" class="source">
    <pre><code>def set_best_latency(self, best_latency: float) -> 'WrappedRedvoxPacket':
    """
    Sets the best latency in the packet's metadata.
    :param best_latency: The best latency to use.
    :return: An instance of this wrapped packet.
    """
    return self.add_metadata("bestLatency", str(best_latency))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_best_offset">
    <p>def <span class="ident">set_best_offset</span>(</p><p>self, best_offset)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets the best offset in the packet's metadata.
:param best_offset: The best offset to use.
:return: An instance of this wrapped packet.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_best_offset', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_best_offset" class="source">
    <pre><code>def set_best_offset(self, best_offset: float) -> 'WrappedRedvoxPacket':
    """
    Sets the best offset in the packet's metadata.
    :param best_offset: The best offset to use.
    :return: An instance of this wrapped packet.
    """
    return self.add_metadata("bestOffset", str(best_offset))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_make">
    <p>def <span class="ident">set_device_make</span>(</p><p>self, make)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the make of the device
:param make: make of the device string</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_make', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_make" class="source">
    <pre><code>def set_device_make(self, make: str) -> 'WrappedRedvoxPacket':
    """
    sets the make of the device
    :param make: make of the device string
    """
    self._redvox_packet.device_make = make
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_model">
    <p>def <span class="ident">set_device_model</span>(</p><p>self, model)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the model of the device
:param model: model of the device string</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_model', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_model" class="source">
    <pre><code>def set_device_model(self, model: str) -> 'WrappedRedvoxPacket':
    """
    sets the model of the device
    :param model: model of the device string
    """
    self._redvox_packet.device_model = model
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_os">
    <p>def <span class="ident">set_device_os</span>(</p><p>self, device_os)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the device operating system
:param device_os: operating system string</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_os', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_os" class="source">
    <pre><code>def set_device_os(self, device_os: str) -> 'WrappedRedvoxPacket':
    """
    sets the device operating system
    :param device_os: operating system string
    """
    self._redvox_packet.device_os = device_os
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_os_version">
    <p>def <span class="ident">set_device_os_version</span>(</p><p>self, version)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the device OS version
:param version: device OS version string</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_os_version', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_os_version" class="source">
    <pre><code>def set_device_os_version(self, version: str) -> 'WrappedRedvoxPacket':
    """
    sets the device OS version
    :param version: device OS version string
    """
    self._redvox_packet.device_os_version = version
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_temperature_c">
    <p>def <span class="ident">set_device_temperature_c</span>(</p><p>self, temp)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the device temperature in degrees Celsius
:param temp: temperature in degrees Celsius</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_temperature_c', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_device_temperature_c" class="source">
    <pre><code>def set_device_temperature_c(self, temp: float) -> 'WrappedRedvoxPacket':
    """
    sets the device temperature in degrees Celsius
    :param temp: temperature in degrees Celsius
    """
    self._redvox_packet.device_temperature_c = temp
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_firebase_token">
    <p>def <span class="ident">set_firebase_token</span>(</p><p>self, token)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the firebase token
:param token: firebase token string</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_firebase_token', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_firebase_token" class="source">
    <pre><code>def set_firebase_token(self, token: str) -> 'WrappedRedvoxPacket':
    """
    sets the firebase token
    :param token: firebase token string
    """
    self._redvox_packet.firebase_token = token
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_gyroscope_channel">
    <p>def <span class="ident">set_gyroscope_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>set_gyroscope_channel has been deprecated in version 2.0.0. Use set_gyroscope_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_gyroscope_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_gyroscope_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", set_gyroscope_sensor)
def set_gyroscope_channel(self, gyroscope_sensor: typing.Optional[
        _gyroscope_sensor.GyroscopeSensor]) -> 'WrappedRedvoxPacket':
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_gyroscope_sensor">
    <p>def <span class="ident">set_gyroscope_sensor</span>(</p><p>self, gyroscope_sensor)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets this packet's gyroscope sensor. A channel can be removed by passing in None.
:param gyroscope_sensor: An optional instance of a gyroscope sensor.
:return: This instance of a wrapped redvox packet.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_gyroscope_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_gyroscope_sensor" class="source">
    <pre><code>def set_gyroscope_sensor(self, gyroscope_sensor: typing.Optional[
        _gyroscope_sensor.GyroscopeSensor]) -> 'WrappedRedvoxPacket':
    """
    Sets this packet's gyroscope sensor. A channel can be removed by passing in None.
    :param gyroscope_sensor: An optional instance of a gyroscope sensor.
    :return: This instance of a wrapped redvox packet.
    """
    if self.has_gyroscope_sensor():
        self._delete_channel(api900_pb2.GYROSCOPE_X)
    if gyroscope_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(gyroscope_sensor._unevenly_sampled_channel)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_image_channel">
    <p>def <span class="ident">set_image_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>set_image_channel has been deprecated in version 2.0.0. Use set_image_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_image_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_image_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", set_image_sensor)
def set_image_channel(self, image_sensor: typing.Optional[_image_sensor.ImageSensor]) -> 'WrappedRedvoxPacket':
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_image_sensor">
    <p>def <span class="ident">set_image_sensor</span>(</p><p>self, image_sensor)</p>
    </div>
    

    
  
    <div class="desc"><p>Set's the image channel.
:param image_sensor: Image sensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_image_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_image_sensor" class="source">
    <pre><code>def set_image_sensor(self, image_sensor: typing.Optional[_image_sensor.ImageSensor]) -> 'WrappedRedvoxPacket':
    """
    Set's the image channel.
    :param image_sensor: Image sensor.
    """
    if self.has_image_sensor():
        self._delete_channel(api900_pb2.IMAGE)
    if image_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(image_sensor._unevenly_sampled_channel)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_infrared_channel">
    <p>def <span class="ident">set_infrared_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>set_infrared_channel has been deprecated in version 2.0.0. Use set_infrared_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_infrared_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_infrared_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", set_infrared_sensor)
def set_infrared_channel(self,
                         infrared_sensor: typing.Optional[
                             _infrared_sensor.InfraredSensor]) -> 'WrappedRedvoxPacket':
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_infrared_sensor">
    <p>def <span class="ident">set_infrared_sensor</span>(</p><p>self, infrared_sensor)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets this packet's infrared sensor. A channel can be removed by passing in None.
:param infrared_sensor: An optional instance of a infrared sensor.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_infrared_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_infrared_sensor" class="source">
    <pre><code>def set_infrared_sensor(self,
                        infrared_sensor: typing.Optional[
                            _infrared_sensor.InfraredSensor]) -> 'WrappedRedvoxPacket':
    """
    Sets this packet's infrared sensor. A channel can be removed by passing in None.
    :param infrared_sensor: An optional instance of a infrared sensor.
    """
    if self.has_infrared_sensor():
        self._delete_channel(api900_pb2.INFRARED)
    if infrared_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(infrared_sensor._unevenly_sampled_channel)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_backfilled">
    <p>def <span class="ident">set_is_backfilled</span>(</p><p>self, tof)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the is_backfilled flag
:param tof: true or false</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_backfilled', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_backfilled" class="source">
    <pre><code>def set_is_backfilled(self, tof: bool) -> 'WrappedRedvoxPacket':
    """
    sets the is_backfilled flag
    :param tof: true or false
    """
    self._redvox_packet.is_backfilled = tof
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_private">
    <p>def <span class="ident">set_is_private</span>(</p><p>self, tof)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the is_private flag
:param tof: true or false</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_private', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_private" class="source">
    <pre><code>def set_is_private(self, tof: bool) -> 'WrappedRedvoxPacket':
    """
    sets the is_private flag
    :param tof: true or false
    """
    self._redvox_packet.is_private = tof
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_scrambled">
    <p>def <span class="ident">set_is_scrambled</span>(</p><p>self, tof)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the is_scrambled flag
:param tof: true or false</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_scrambled', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_scrambled" class="source">
    <pre><code>def set_is_scrambled(self, tof: bool) -> 'WrappedRedvoxPacket':
    """
    sets the is_scrambled flag
    :param tof: true or false
    """
    self._redvox_packet.is_scrambled = tof
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_synch_corrected">
    <p>def <span class="ident">set_is_synch_corrected</span>(</p><p>self, is_synch_corrected)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets the is_synch_corrected field in the packet's metadata.
:param is_synch_corrected: The is_synch_corrected field to use.
:return: An instance of this wrapped packet.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_synch_corrected', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_is_synch_corrected" class="source">
    <pre><code>def set_is_synch_corrected(self, is_synch_corrected: bool) -> 'WrappedRedvoxPacket':
    """
    Sets the is_synch_corrected field in the packet's metadata.
    :param is_synch_corrected: The is_synch_corrected field to use.
    :return: An instance of this wrapped packet.
    """
    return self.add_metadata("isSynchCorrected", "true" if is_synch_corrected else "false")
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_light_channel">
    <p>def <span class="ident">set_light_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>set_light_channel has been deprecated in version 2.0.0. Use set_light_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_light_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_light_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", set_light_sensor)
def set_light_channel(self, light_sensor: typing.Optional[_light_sensor.LightSensor]) -> 'WrappedRedvoxPacket':
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_light_sensor">
    <p>def <span class="ident">set_light_sensor</span>(</p><p>self, light_sensor)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets this packet's light sensor. A channel can be removed by passing in None.
:param light_sensor: An optional instance of a light sensor.
:return: This instance of a wrapped redvox packet.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_light_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_light_sensor" class="source">
    <pre><code>def set_light_sensor(self, light_sensor: typing.Optional[_light_sensor.LightSensor]) -> 'WrappedRedvoxPacket':
    """
    Sets this packet's light sensor. A channel can be removed by passing in None.
    :param light_sensor: An optional instance of a light sensor.
    :return: This instance of a wrapped redvox packet.
    """
    if self.has_light_sensor():
        self._delete_channel(api900_pb2.LIGHT)
    if light_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(light_sensor._unevenly_sampled_channel)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_location_channel">
    <p>def <span class="ident">set_location_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>set_location_channel has been deprecated in version 2.0.0. Use set_location_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_location_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_location_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", set_location_sensor)
def set_location_channel(self,
                         location_sensor: typing.Optional[
                             _location_sensor.LocationSensor]) -> 'WrappedRedvoxPacket':
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_location_sensor">
    <p>def <span class="ident">set_location_sensor</span>(</p><p>self, location_sensor)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets this packet's location sensor. A channel can be removed by passing in None.
:param location_sensor: An optional instance of a location sensor.
:return: This instance of a wrapped redvox packet.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_location_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_location_sensor" class="source">
    <pre><code>def set_location_sensor(self,
                        location_sensor: typing.Optional[_location_sensor.LocationSensor]) -> 'WrappedRedvoxPacket':
    """
    Sets this packet's location sensor. A channel can be removed by passing in None.
    :param location_sensor: An optional instance of a location sensor.
    :return: This instance of a wrapped redvox packet.
    """
    if self.has_location_sensor():
        self._delete_channel(api900_pb2.LATITUDE)
    if location_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(location_sensor._unevenly_sampled_channel)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_mach_time_zero">
    <p>def <span class="ident">set_mach_time_zero</span>(</p><p>self, mach_time_zero)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets the mach time zero in the packet's metadata.
:param mach_time_zero: The mach time zero to use.
:return: An instance of this wrapped packet.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_mach_time_zero', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_mach_time_zero" class="source">
    <pre><code>def set_mach_time_zero(self, mach_time_zero: int) -> 'WrappedRedvoxPacket':
    """
    Sets the mach time zero in the packet's metadata.
    :param mach_time_zero: The mach time zero to use.
    :return: An instance of this wrapped packet.
    """
    return self.add_metadata("machTimeZero", str(mach_time_zero))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_magnetometer_channel">
    <p>def <span class="ident">set_magnetometer_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>set_magnetometer_channel has been deprecated in version 2.0.0. Use set_magnetometer_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_magnetometer_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_magnetometer_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", set_magnetometer_sensor)
def set_magnetometer_channel(self,
                             magnetometer_sensor: typing.Optional[
                                 _magnetometer_sensor.MagnetometerSensor]) -> 'WrappedRedvoxPacket':
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_magnetometer_sensor">
    <p>def <span class="ident">set_magnetometer_sensor</span>(</p><p>self, magnetometer_sensor)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets this packet's magnetomer sensor. A channel can be removed by passing in None.
:param magnetometer_sensor: An optional instance of a magnetometer sensor.
:return: This instance of a wrapped redvox packet.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_magnetometer_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_magnetometer_sensor" class="source">
    <pre><code>def set_magnetometer_sensor(self,
                            magnetometer_sensor: typing.Optional[
                                _magnetometer_sensor.MagnetometerSensor]) -> 'WrappedRedvoxPacket':
    """
    Sets this packet's magnetomer sensor. A channel can be removed by passing in None.
    :param magnetometer_sensor: An optional instance of a magnetometer sensor.
    :return: This instance of a wrapped redvox packet.
    """
    if self.has_magnetometer_sensor():
        self._delete_channel(api900_pb2.MAGNETOMETER_X)
    if magnetometer_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(magnetometer_sensor._unevenly_sampled_channel)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_metadata">
    <p>def <span class="ident">set_metadata</span>(</p><p>self, data)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the metadata
:param data: metadata as list of strings</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_metadata', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_metadata" class="source">
    <pre><code>def set_metadata(self, data: typing.List[str]) -> 'WrappedRedvoxPacket':
    """
    sets the metadata
    :param data: metadata as list of strings
    """
    self._metadata_list = data
    self._redvox_packet.metadata[:] = data
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_metadata_as_dict">
    <p>def <span class="ident">set_metadata_as_dict</span>(</p><p>self, metadata_dict)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets the metadata using a dictionary.
:param metadata_dict: Dictionary of metadata.
:return: This WrappedRedvoxPacket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_metadata_as_dict', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_metadata_as_dict" class="source">
    <pre><code>def set_metadata_as_dict(self, metadata_dict: typing.Dict[str, str]) -> 'WrappedRedvoxPacket':
    """
    Sets the metadata using a dictionary.
    :param metadata_dict: Dictionary of metadata.
    :return: This WrappedRedvoxPacket.
    """
    self.set_metadata(reader_utils.metadata_dict_to_list(metadata_dict))
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_microphone_channel">
    <p>def <span class="ident">set_microphone_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>set_microphone_channel has been deprecated in version 2.0.0. Use set_microphone_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_microphone_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_microphone_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", set_microphone_sensor)
def set_microphone_channel(self, microphone_sensor: typing.Optional[
        _microphone_sensor.MicrophoneSensor]) -> 'WrappedRedvoxPacket':
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_microphone_sensor">
    <p>def <span class="ident">set_microphone_sensor</span>(</p><p>self, microphone_sensor)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets this packets microphone sensor. A channel can be removed by passing in None.
:param microphone_sensor: An optional instance of a microphone sensor.
:return: This instance of a wrapped redvox packet.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_microphone_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_microphone_sensor" class="source">
    <pre><code>def set_microphone_sensor(self, microphone_sensor: typing.Optional[
        _microphone_sensor.MicrophoneSensor]) -> 'WrappedRedvoxPacket':
    """
    Sets this packets microphone sensor. A channel can be removed by passing in None.
    :param microphone_sensor: An optional instance of a microphone sensor.
    :return: This instance of a wrapped redvox packet.
    """
    if self.has_microphone_sensor():
        self._delete_channel(api900_pb2.MICROPHONE)
    if microphone_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(microphone_sensor._evenly_sampled_channel)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_redvox_id">
    <p>def <span class="ident">set_redvox_id</span>(</p><p>self, rid)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the redvox id
:param rid: redvox id string</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_redvox_id', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_redvox_id" class="source">
    <pre><code>def set_redvox_id(self, rid: str) -> 'WrappedRedvoxPacket':
    """
    sets the redvox id
    :param rid: redvox id string
    """
    self._redvox_packet.redvox_id = rid
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_server_timestamp_epoch_microseconds_utc">
    <p>def <span class="ident">set_server_timestamp_epoch_microseconds_utc</span>(</p><p>self, time)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the server timestamp when the packet was received
:param time: time when packet was received by server</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_server_timestamp_epoch_microseconds_utc', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_server_timestamp_epoch_microseconds_utc" class="source">
    <pre><code>def set_server_timestamp_epoch_microseconds_utc(self, time: int) -> 'WrappedRedvoxPacket':
    """
    sets the server timestamp when the packet was received
    :param time: time when packet was received by server
    """
    self._redvox_packet.server_timestamp_epoch_microseconds_utc = time
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_time_synchronization_channel">
    <p>def <span class="ident">set_time_synchronization_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>set_time_synchronization_channel has been deprecated in version 2.0.0. Use set_time_synchronization_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_time_synchronization_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_time_synchronization_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", set_time_synchronization_sensor)
def set_time_synchronization_channel(self, time_synchronization_sensor: typing.Optional[
        _time_synchronization_sensor.TimeSynchronizationSensor]) -> 'WrappedRedvoxPacket':
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_time_synchronization_sensor">
    <p>def <span class="ident">set_time_synchronization_sensor</span>(</p><p>self, time_synchronization_sensor)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets this packet's time sync sensor. A channel can be removed by passing in None.
:param time_synchronization_sensor: An optional instance of a time sync sensor.
:return: This instance of a wrapped redvox packet.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_time_synchronization_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_time_synchronization_sensor" class="source">
    <pre><code>def set_time_synchronization_sensor(self, time_synchronization_sensor: typing.Optional[
        _time_synchronization_sensor.TimeSynchronizationSensor]) -> 'WrappedRedvoxPacket':
    """
    Sets this packet's time sync sensor. A channel can be removed by passing in None.
    :param time_synchronization_sensor: An optional instance of a time sync sensor.
    :return: This instance of a wrapped redvox packet.
    """
    if self.has_time_synchronization_sensor():
        self._delete_channel(api900_pb2.TIME_SYNCHRONIZATION)
    if time_synchronization_sensor is not None:
        # pylint: disable=W0212
        self._add_channel(time_synchronization_sensor._unevenly_sampled_channel)
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_time_synchronization_server">
    <p>def <span class="ident">set_time_synchronization_server</span>(</p><p>self, server)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the time synchronization server url
:param server: url to time synchronization server</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_time_synchronization_server', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_time_synchronization_server" class="source">
    <pre><code>def set_time_synchronization_server(self, server: str) -> 'WrappedRedvoxPacket':
    """
    sets the time synchronization server url
    :param server: url to time synchronization server
    """
    self._redvox_packet.time_synchronization_server = server
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_uuid">
    <p>def <span class="ident">set_uuid</span>(</p><p>self, uid)</p>
    </div>
    

    
  
    <div class="desc"><p>sets the uuid
:param uid: uuid string</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_uuid', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.set_uuid" class="source">
    <pre><code>def set_uuid(self, uid: str) -> 'WrappedRedvoxPacket':
    """
    sets the uuid
    :param uid: uuid string
    """
    self._redvox_packet.uuid = uid
    return self
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.start_timestamp_us_utc">
    <p>def <span class="ident">start_timestamp_us_utc</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the start timestamp of a WrappedRedvoxPacket.
:return: The start timestamp of a WrappedRedvoxPacket.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.start_timestamp_us_utc', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.start_timestamp_us_utc" class="source">
    <pre><code>def start_timestamp_us_utc(self) -> int:
    """
    Returns the start timestamp of a WrappedRedvoxPacket.
    :return: The start timestamp of a WrappedRedvoxPacket.
    """
    return self.microphone_sensor().first_sample_timestamp_epoch_microseconds_utc()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.time_synchronization_channel">
    <p>def <span class="ident">time_synchronization_channel</span>(</p><p>*args, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>time_synchronization_channel has been deprecated in version 2.0.0. Use time_synchronization_sensor instead.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.time_synchronization_channel', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.time_synchronization_channel" class="source">
    <pre><code>@deprecation.deprecated("2.0.0", time_synchronization_sensor)
def time_synchronization_channel(self) -> typing.Optional[_time_synchronization_sensor.TimeSynchronizationSensor]:
    """
    This method has been deprecated. See the sensor method equivalent.
    """
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.time_synchronization_sensor">
    <p>def <span class="ident">time_synchronization_sensor</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the high-level time synchronization channel API or None if this packet doesn't contain a channel of
this type.
:return: the high-level time synchronization channel API or None if this packet doesn't contain a channel of
this type.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.time_synchronization_sensor', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.time_synchronization_sensor" class="source">
    <pre><code>def time_synchronization_sensor(self) -> typing.Optional[_time_synchronization_sensor.TimeSynchronizationSensor]:
    """
    Returns the high-level time synchronization channel API or None if this packet doesn't contain a channel of
    this type.
    :return: the high-level time synchronization channel API or None if this packet doesn't contain a channel of
    this type.
    """
    if self.has_time_synchronization_sensor():
        return _time_synchronization_sensor.TimeSynchronizationSensor(
            self._get_channel(api900_pb2.TIME_SYNCHRONIZATION))
    return None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.time_synchronization_server">
    <p>def <span class="ident">time_synchronization_server</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.time_synchronization_server', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.time_synchronization_server" class="source">
    <pre><code>def time_synchronization_server(self) -> str:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.time_synchronization_server
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.to_json">
    <p>def <span class="ident">to_json</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Converts the protobuf packet stored in this wrapped packet to JSON.
:return: The JSON representation of the protobuf encoded packet.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.to_json', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.to_json" class="source">
    <pre><code>def to_json(self) -> str:
    """
    Converts the protobuf packet stored in this wrapped packet to JSON.
    :return: The JSON representation of the protobuf encoded packet.
    """
    return reader_utils.to_json(self._redvox_packet)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.update_uneven_sensor_timestamps">
    <p>def <span class="ident">update_uneven_sensor_timestamps</span>(</p><p>self, time_delta)</p>
    </div>
    

    
  
    <div class="desc"><p>Given a time delta in microseconds, will adjust all unevenly sampled sensor timestamps by that amount.
Use negative values to adjust backwards in time.
:param time_delta: amount of time to adjust timestamps in microseconds</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.update_uneven_sensor_timestamps', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.update_uneven_sensor_timestamps" class="source">
    <pre><code>def update_uneven_sensor_timestamps(self, time_delta: int or float):
    """
    Given a time delta in microseconds, will adjust all unevenly sampled sensor timestamps by that amount.
    Use negative values to adjust backwards in time.
    :param time_delta: amount of time to adjust timestamps in microseconds
    """
    for channel in self._unevenly_sampled_channels_field:
        if not channel.has_channel(api900_pb2.TIME_SYNCHRONIZATION):
            channel.set_timestamps_microseconds_utc(channel.timestamps_microseconds_utc + time_delta)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.uuid">
    <p>def <span class="ident">uuid</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
description of this field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.uuid', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.uuid" class="source">
    <pre><code>def uuid(self) -> str:
    """
    See https://bitbucket.org/redvoxhi/redvox-data-apis/src/master/src/api900/api900.proto?at=master for a
    description of this field.
    """
    return self._redvox_packet.uuid
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.write_json">
    <p>def <span class="ident">write_json</span>(</p><p>self, directory, filename=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Writes a RedVox compliant .json file to the specified directory.
:param directory: The directory to write the file to.
:param filename: An optional filename (the default filename will be used if one is not provided).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.write_json', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.write_json" class="source">
    <pre><code>def write_json(self, directory: str, filename: typing.Optional[str] = None):
    """
    Writes a RedVox compliant .json file to the specified directory.
    :param directory: The directory to write the file to.
    :param filename: An optional filename (the default filename will be used if one is not provided).
    """
    filename = self.default_filename(extension="json") if filename is None else filename
    path = os.path.join(directory, filename)
    with open(path, "w") as json_out:
        json_out.write(self.to_json())
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.write_rdvxz">
    <p>def <span class="ident">write_rdvxz</span>(</p><p>self, directory, filename=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Writes a compressed .rdvxz file to the specified directory.
:param directory: The directory to write the file to.
:param filename: An optional filename (the default filename will be used if one is not provided).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.write_rdvxz', this);">Show source &equiv;</a></p>
  <div id="source-redvox.api900.wrapped_redvox_packet.WrappedRedvoxPacket.write_rdvxz" class="source">
    <pre><code>def write_rdvxz(self, directory: str, filename: typing.Optional[str] = None):
    """
    Writes a compressed .rdvxz file to the specified directory.
    :param directory: The directory to write the file to.
    :param filename: An optional filename (the default filename will be used if one is not provided).
    """
    filename = self.default_filename() if filename is None else filename
    path = os.path.join(directory, filename)
    with open(path, "wb") as rdvxz_out:
        rdvxz_out.write(self.compressed_buffer())
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
